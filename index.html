<!doctype html>
<html>
  <head>
    <title>Socket.IO chat</title>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      body { font: 13px Helvetica, Arial;  overflow: hidden; }
      form { background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; }
      form input { border: 0; padding: 10px; width: 90%; margin-right: .5%; }
      form button { width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; }
      #messages { list-style-type: none; margin: 0; padding: 0; }
      #messages li { padding: 5px 10px; }
      #messages li:nth-child(odd) { background: #eee; }
    </style>
  </head>
  <body>

	<script src="/socket.io/socket.io.js"></script>
	
	<canvas id="myCanvas" width="1280" height="720"></canvas>

	<script>

	var canvas = document.getElementById("myCanvas");
	var ctx = canvas.getContext("2d");
	ctx.canvas.width  = window.innerWidth;
	ctx.canvas.height = window.innerHeight;

	var taxisize = 0;
	var taxiWidth = 15;
	var taxiHeight = 34;
	var passengers = 0;
	var max_passengers = 1;
	var passenger_offset_x = [0,6,-6,0,6,-6,0,6,-6,0,6,-6];
	var passenger_offset_y = [-4,-4,-4,-12,-12,-12,-20,-20,-20,-28,-28,-28];
	var taxiConfig = getTaxiConfig(taxisize);

	var handlingLevel = 0;
	var handlingLevel_max = 5;
	var taxilevel = 0;
	var taxilevel_max = 6;
	var turningSpeed = getHandling(handlingLevel);
	var autoPilotturningSpeed = 8;
	var pos_x = Math.floor((Math.random() * (canvas.width-100)) + 50);
	var pos_y = Math.floor((Math.random() * (canvas.height-100)) + 50);
	var points = 0;
	var min_viewdistance = 500;
	var highscore = 0;
	var highscore_name = "NoOne";
	var name = "Player1";
	var myID = Math.floor((Math.random() * 1000)) + 1;
	var fieldwidth = 4000;
	var fieldheight = 4000;
	var field_x = 0;
	var field_y = 0;
	var connected = false;
	var taxis = [];
	var houses = [];
	var bases = [];
	var passengersList = [];
	var now = Date.now();
	var time = now;
	var spawnTime = now;
	var lastCargo = now;
	var lastLogged = now;
	var lastShot = now;
	var logInterval = 500;
	var dt = 0;
	var cargo = [];
	var base = { x:75, y:75, radius:75};
	var rightPressed = false;
	var leftPressed = false;
	var forwardPressed = false;
	var socket = io();
	var debug = false;
	var target = {x:-1,y:-1};
	var level = 0;
	var experience = 0;
	var skillpoints = 0;
	var brakelevel = 0;
	var brakelevel_max = 5;
	var decelaration = 80;
	var breaking = false;
	var drifting = false;
	var max_turning_speed = 8;
	var projectiles = [];
	var taxiImage = new Image();
	taxiImage.src = "/img/taxi.png";
	taxiImage.onload = function() {
		ctx.drawImage(taxiImage,0,0);
	};
	
	var steer_angle = 0;
	var steer_factor = 3;
	var direction = 0; // -PI to +Pi
	var speed = 0;
	var max_speed = 180;
	var acceleration = 80;
	var old = {x:100,y:100};

	ctx.font = "10px Arial";

	socket.on('data', function(servercargo){
		cargo = servercargo;
	});

	socket.on('taxis', function(servertaxis){
		taxis = servertaxis;
	});

	socket.on('projectiles', function(serverprojectiles){
		projectiles = serverprojectiles;
	});

  socket.on('houses', function(serverhouses){

	console.log("Getting houses");
     houses = serverhouses;
  }); 
  socket.on('bases', function(serverbases){

		console.log("Getting bases:")
	     bases = serverbases;
	  });

	socket.on('score', function(score){
		highscore = score.highscore;
		highscore_name = score.name;
	});

	document.addEventListener("keydown", keyDownHandler, false);
	document.addEventListener("keyup", keyUpHandler, false);

	function autoPilot(){

		var targetFound = false;
		var min_distance = -1;
		if((passengers == max_passengers) || (cargo.length == 0)){
			target = {x:base.x, y:base.y};
			autoPilotGoToTarget();
		}
		else{
			for(var c = 0; c < cargo.length; c++){
				if(targetFound == false && cargo[c].x > 30 && cargo[c].x < (fieldwidth-30) && cargo[c].y > 30 && cargo[c].y < (fieldheight-30) ){
					target = {x: cargo[c].x, y:cargo[c].y};
					min_distance = Math.sqrt(Math.pow(pos_x - cargo[c].x,2)+Math.pow(pos_y - cargo[c].y,2));
					targetFound = true;
				}
				else{
					if( (min_distance - Math.sqrt(Math.pow(pos_x - cargo[c].x,2)+Math.pow(pos_y - cargo[c].y,2))) > 0){
						target = {x: cargo[c].x, y:cargo[c].y};
						min_distance = Math.sqrt(Math.pow(pos_x - cargo[c].x,2)+Math.pow(pos_y - cargo[c].y,2));
					}
				}
			}

		}
		if(targetFound){
			autoPilotGoToTarget();
		}
		if(skillpoints > 0) {
			if (taxilevel < taxilevel_max) {
				taxilevel++;

				taxiConfig = getTaxiConfig(taxilevel);
				max_passengers = getTaxiConfig(taxilevel).max_passengers;
				taxiWidth = getTaxiConfig(taxilevel).taxiWidth;
				taxiHeight = getTaxiConfig(taxilevel).taxiHeight;

				skillpoints--;
			}
		}

	}

	function autoPilotGoToTarget() {

		var crossProduct = Math.sin(direction) * (pos_y - target.y) - ( Math.cos(direction) * (pos_x - target.x)  );
		//console.log("direction: " + direction + " target: " + target.x + "/" + target.y + " cross: " + crossProduct);
		if (Math.abs(crossProduct) > 1) {

			if (crossProduct > 0) {

				direction = (((direction + (2 * autoPilotturningSpeed * dt)) + Math.PI) % (2 * Math.PI)) - Math.PI;
				crossProduct = Math.sin(direction) * (pos_y - target.y) - ( Math.cos(direction) * (pos_x - target.x)  );
				if (crossProduct < 0) {
					direction = Math.atan2(target.x-pos_x,target.y-pos_y);
				}
			}
			else {
				if ((direction - (0.5 * dt)) < (-Math.PI)) {
					direction = (direction - (2 * autoPilotturningSpeed * dt)) + 2 * Math.PI;
				}
				else {
					direction = (((direction - (2 * autoPilotturningSpeed * dt)) + Math.PI) % (2 * Math.PI)) - Math.PI;
				}

				crossProduct = Math.sin(direction) * (pos_y - target.y) - ( Math.cos(direction) * (pos_x - target.x)  );
				if (crossProduct > 0) {
					direction = Math.atan2(target.x-pos_x,target.y-pos_y);
				}
			}
		}


	}
	
	function baseArrow(baseNumber){
		
		var targetBase = bases[baseNumber];
		ctx.save();
		ctx.translate(-field_x,-field_y);
		
		ctx.beginPath();
		ctx.lineWidth="5";
		switch(targetBase.color) {
			case 0:
				ctx.fillStyle = "red";
				break;
			case 1:
				ctx.fillStyle = "pink";
				break;
			case 2:
				ctx.fillStyle = "yellow";
				break;
			case 3:
				ctx.fillStyle = "green";
				break;
			case 4:
				ctx.fillStyle = "blue";
				break;
			default:
				ctx.fillStyle = "green";
				break;
		}
		
		//Determine Center of base
		var x=0;
		var y=0;
		for(var i = 0;i<targetBase.form.length;i++) {
			x = x+targetBase.form[i].x;
			y = y+targetBase.form[i].y;
		}
		x=x/targetBase.form.length;
		y=y/targetBase.form.length;
		
		//Determine angle to center
		var angle = Math.atan2(x-pos_x, y -pos_y);
		
		ctx.moveTo(pos_x,pos_y);		
		ctx.moveTo(pos_x + Math.sin(angle)*30, pos_y + Math.cos(angle)*30 );
		ctx.lineTo(pos_x + 25*Math.sin(angle-Math.PI/12),pos_y + 25*Math.cos(angle-Math.PI/12));
		ctx.lineTo(pos_x + 25*Math.sin(angle+Math.PI/12),pos_y + 25*Math.cos(angle+Math.PI/12));
		ctx.lineTo(pos_x + Math.sin(angle)*30, pos_y + Math.cos(angle)*30 );
		ctx.fill();
		ctx.closePath();

		ctx.restore();
	

	}
	function visualizeAngles(){
		//console.log("Visualizing Direction Angle");

		ctx.save();
		ctx.translate(-field_x,-field_y);

		ctx.beginPath();
		ctx.lineWidth="5";
		ctx.strokeStyle = "orange";
		ctx.moveTo(pos_x,pos_y);
		ctx.lineTo(pos_x + Math.sin(direction)*30, pos_y + Math.cos(direction)*30 );
		ctx.stroke();
		ctx.closePath();

		ctx.beginPath();
		ctx.lineWidth="5";
		ctx.strokeStyle = "pink";
		ctx.moveTo(pos_x,pos_y);
		ctx.lineTo(pos_x + Math.sin(Math.atan2(target.x - pos_x,target.y-pos_y))*30, pos_y + Math.cos(Math.atan2(target.x-pos_x, target.y -pos_y))*30 );
		ctx.stroke();
		ctx.closePath();

		ctx.restore();

	}

	function mypoint(x,y){
		this.x = x;
		this.y = y;
	}

	function draw(){
		requestAnimationFrame(draw);
		now = Date.now();
		dt = (now - time)*0.001;
		time = now;
		ctx.clearRect(0, 0, canvas.width, canvas.height);



		drawHouses();
		drawBase();
		drawTaxi();
		drawScore();
		drawCargo();
		drawTaxis();
		drawExperienceBar();
		drawSkills();
		drawProjectiles();

		ctx.save();
		ctx.translate(-field_x,-field_y);
		ctx.beginPath();
		ctx.lineWidth="6";
		ctx.strokeStyle="black";
		ctx.rect(3,3, fieldwidth-6, fieldheight-6);
		ctx.stroke();
		ctx.closePath();
		ctx.restore();

		if(debug){
			visualizeAngles();
		}

		this.act();

		if((now-lastCargo) > 500){
			socket.emit("position",{id:myID,pos_x:pos_x,pos_y:pos_y,
				direction:direction,name:"MyName",lastUpdate:Date.now(),
				taxiWidth:taxiWidth,taxiHeight:taxiHeight,
				speed:speed,leftPressed:leftPressed,rightPressed:rightPressed,
				passengers:passengers});
		}

		logger();

	}

	reset();
	draw();

	function drawTaxi() {

		ctx.save();
		ctx.translate(pos_x, pos_y);
		ctx.translate(-field_x,-field_y);
		ctx.rotate(-direction);
		//ctx.fillStyle = "blue";
		ctx.drawImage(taxiImage,-taxiWidth/2, -taxiHeight/2, taxiWidth, taxiHeight);
		//ctx.fillRect(-taxiWidth / 2, -taxiHeight / 2, taxiWidth, taxiHeight);
		ctx.restore();

		ctx.save();
		ctx.translate(-field_x,-field_y);
		ctx.translate(pos_x, pos_y);
		ctx.rotate(-direction);
		ctx.beginPath();
		ctx.fillStyle = "black";
		ctx.arc(taxiConfig.pilot_x, taxiConfig.pilot_y, 3, 0, 2 * Math.PI);
		ctx.fill();
		ctx.closePath();
		ctx.restore();

		for (var p = 0; p < passengers; p++) {
			ctx.save();
			ctx.translate(pos_x, pos_y);
			ctx.translate(-field_x,-field_y);
			ctx.rotate(-direction);
			ctx.beginPath();
			switch(passengersList[p].color){
				case 0:
					ctx.fillStyle = "red";
					break;
				case 1:
					ctx.fillStyle = "pink";
					break;
				case 2:
					ctx.fillStyle = "yellow";
					break;
				case 3:
					ctx.fillStyle = "green";
					break;
				case 4:
					ctx.fillStyle = "blue";
					break;
				default:
					ctx.fillStyle = "red";
					break;
			}
			
			//ctx.fillStyle = "red";
			ctx.arc(taxiConfig.passenger_offset_x[p], taxiConfig.passenger_offset_y[p], 3, 0, 2 * Math.PI);
			ctx.fill();
			ctx.closePath();
			ctx.restore();

			baseArrow(passengersList[p].color);
		}

		if (pos_y + min_viewdistance > field_y + canvas.height) {
			field_y = field_y + ((pos_y + min_viewdistance) - (field_y + canvas.height));
			//field_y = field_y + Math.cos(direction)*speed;
		}
		if (pos_y - min_viewdistance < field_y) {
			field_y = field_y - (-(pos_y - min_viewdistance) + (field_y ));
		}
		//if (field_y < 0) {
		//	field_y = 0;
		//}
		//if (field_y + canvas.height > fieldheight) {
		//	field_y = fieldheight - canvas.height
		//}
		if (pos_x + min_viewdistance > field_x + canvas.width) {
			field_x = field_x + ((pos_x + min_viewdistance) - (field_x + canvas.width));
		}
		if (pos_x - min_viewdistance < field_x) {
			field_x = field_x - (-(pos_x - min_viewdistance) + (field_x ));
		}
		//if (field_x < 0) {
		//	field_x = 0;
		//}
		//if (field_x + canvas.width > fieldwidth) {
		//	field_x = fieldwidth - canvas.width
		//}

	}

	function drawTaxis(){
		for (var t = 0; t < taxis.length; t++) {
			if(taxis[t].id != myID) {
				ctx.save();
				ctx.translate(-field_x,-field_y);
				ctx.translate(taxis[t].pos_x, taxis[t].pos_y);
				ctx.rotate(-taxis[t].direction);
				ctx.fillStyle = "blue";
				ctx.fillRect(-taxis[t].taxiWidth / 2, -taxis[t].taxiHeight / 2, taxis[t].taxiWidth, taxis[t].taxiHeight);

				ctx.restore();

				ctx.save();
				ctx.translate(-field_x,-field_y);
				ctx.translate(taxis[t].pos_x, taxis[t].pos_y);
				ctx.rotate(-taxis[t].direction);
				ctx.beginPath();
				ctx.fillStyle = "black";
				ctx.arc(0, 4, 3, 0, 2 * Math.PI);
				ctx.fill();
				ctx.closePath();
				ctx.restore();

				for (var p = 0; p < taxis[t].passengers; p++){
					ctx.save();
					ctx.translate(-field_x,-field_y);
					ctx.translate(taxis[t].pos_x,taxis[t].pos_y);
					ctx.rotate(-taxis[t].direction);
					ctx.beginPath();
					ctx.fillStyle = "red";
					ctx.arc(passenger_offset_x[p],passenger_offset_y[p],3,0,2*Math.PI);
					ctx.fill();
					ctx.closePath();
					ctx.restore();
				}
			}
		}

	}
  
	function drawHouses(){
		for(var i=0;i<houses.length;i++) {
			ctx.save();
			ctx.translate(-field_x,-field_y);
			ctx.beginPath();
			ctx.moveTo(houses[i][0].x,houses[i].y);
			for(dot in houses[i]){
				ctx.lineTo(houses[i][dot].x,houses[i][dot].y);
			}
			ctx.lineTo(houses[i][0].x,houses[i].y);
			ctx.closePath();
			ctx.fillStyle = "black";
			ctx.fill();
			ctx.restore();
		}
	}

	function drawCargo() {
		for(f = 0; f < cargo.length; f++){
			ctx.save();
			ctx.beginPath();
			ctx.translate(-field_x,-field_y);
			ctx.arc(cargo[f].x, cargo[f].y, 3, 0, Math.PI*2);
			switch(cargo[f].color){
				case 0:
					ctx.fillStyle = "red";
					break;
				case 1:
					ctx.fillStyle = "pink";
					break;
				case 2:
					ctx.fillStyle = "yellow";
					break;
				case 3:
					ctx.fillStyle = "green";
					break;
				case 4:
					ctx.fillStyle = "blue";
					break;
				default:
					ctx.fillStyle = "red";
					break;
			}
			ctx.fill();
			ctx.closePath();
			ctx.restore();
		}
	}

	function drawScore(){
		ctx.font = "20px Arial";
		ctx.fillStyle = "grey";
		ctx.fillText("Highscore: " + highscore_name + ": " + highscore ,canvas.width-300,24);
		ctx.fillText("Score: " + points,canvas.width-300,49);
	}

	function drawBase(){

		ctx.save();
		ctx.translate(-field_x,-field_y);

		for(b = 0; b < bases.length; b++){
			switch(bases[b].color) {
				case 0:
					ctx.fillStyle = "red";
					break;
				case 1:
					ctx.fillStyle = "pink";
					break;
				case 2:
					ctx.fillStyle = "yellow";
					break;
				case 3:
					ctx.fillStyle = "green";
					break;
				case 4:
					ctx.fillStyle = "blue";
					break;
				default:
					ctx.fillStyle = "green";
					break;
			}
			ctx.beginPath();
			ctx.moveTo(bases[b].form[0].x, bases[b].form[0].y);
			for(dot in bases[b].form){
				ctx.lineTo(bases[b].form[dot].x, bases[b].form[dot].y);
			}
			ctx.lineTo(bases[b].form[0].x, bases[b].form[0].y);
			ctx.closePath();
			ctx.fill();
		}


		ctx.restore();
	}

	function drawExperienceBar(){

		ctx.save();
		//ctx.translate(-field_x,-field_y);

		ctx.beginPath();
		ctx.lineWidth="2";
		ctx.strokeStyle="grey";
		ctx.rect(canvas.width/2-50, canvas.height-40,100,12);
		ctx.stroke();
		ctx.closePath();
		ctx.restore();

		ctx.beginPath();
		ctx.rect(canvas.width/2-48, canvas.height-38,98,8 );
		ctx.fillStyle = "white";
		ctx.fill();
		ctx.closePath();

		ctx.beginPath();
		ctx.rect(canvas.width/2-48, canvas.height-38, (experience/getExperience(level))*98,8 );
		ctx.fillStyle = "yellow";
		ctx.fill();
		ctx.closePath();

		ctx.font = "15px Arial";
		ctx.fillStyle = "grey";
		ctx.fillText("Level: " + level, canvas.width/2-30,canvas.height-46);


	}

	function drawSkills(){

		var barHeight = 8;
		var frameHeight = 12;
		var frameWidth = 100;
		var barWidth = 96;
		var distance_font = 4;
		var offset_width = 150;
		var border = 2;
		var offsetHeight = 40;
		var heightdifference = 33;
		
		ctx.save();
		//ctx.translate(-field_x,-field_y);

		ctx.beginPath();
		ctx.lineWidth="2";
		ctx.strokeStyle="grey";
		ctx.rect(canvas.width-offset_width, canvas.height-offsetHeight,frameWidth,frameHeight);
		ctx.stroke();
		ctx.closePath();
		ctx.restore();

		ctx.beginPath();
		ctx.rect(canvas.width-offset_width+border, canvas.height-offsetHeight+border, barWidth,barHeight );
		ctx.fillStyle = "white";
		ctx.fill();
		ctx.closePath();

		ctx.beginPath();
		ctx.rect(canvas.width-offset_width+border, canvas.height-offsetHeight+border, ((handlingLevel)/handlingLevel_max)*barWidth,barHeight );
		ctx.fillStyle = "yellow";
		ctx.fill();
		ctx.closePath();

		ctx.font = "15px Arial";
		ctx.fillStyle = "grey";
		ctx.fillText("Handling: " + handlingLevel, canvas.width-offset_width,canvas.height-offsetHeight - distance_font);

		ctx.beginPath();
		ctx.lineWidth="2";
		ctx.strokeStyle="grey";
		ctx.rect(canvas.width-offset_width, canvas.height- offsetHeight - heightdifference, frameWidth,frameHeight);
		ctx.stroke();
		ctx.closePath();
		ctx.restore();

		ctx.beginPath();
		ctx.rect(canvas.width-offset_width+border, canvas.height-offsetHeight - heightdifference +border, barWidth,barHeight );
		ctx.fillStyle = "white";
		ctx.fill();
		ctx.closePath();

		ctx.beginPath();
		ctx.rect(canvas.width-offset_width+border, canvas.height-offsetHeight - heightdifference + border , ((brakelevel)/brakelevel_max)*barWidth,barHeight );
		ctx.fillStyle = "yellow";
		ctx.fill();
		ctx.closePath();

		ctx.font = "15px Arial";
		ctx.fillStyle = "grey";
		ctx.fillText("Brakes: " + brakelevel, canvas.width-offset_width,canvas.height-offsetHeight - heightdifference - distance_font);

		ctx.beginPath();
		ctx.lineWidth="2";
		ctx.strokeStyle="grey";
		ctx.rect(canvas.width-offset_width, canvas.height- offsetHeight - heightdifference*2, frameWidth,frameHeight);
		ctx.stroke();
		ctx.closePath();
		ctx.restore();

		ctx.beginPath();
		ctx.rect(canvas.width-offset_width+border, canvas.height-offsetHeight - heightdifference*2 +border, barWidth,barHeight );
		ctx.fillStyle = "white";
		ctx.fill();
		ctx.closePath();

		ctx.beginPath();
		ctx.rect(canvas.width-offset_width+border, canvas.height-offsetHeight - heightdifference*2 + border , ((taxilevel)/taxilevel_max)*barWidth,barHeight );
		ctx.fillStyle = "yellow";
		ctx.fill();
		ctx.closePath();

		ctx.font = "15px Arial";
		ctx.fillStyle = "grey";
		ctx.fillText("Taxi: " + taxilevel, canvas.width-offset_width,canvas.height-offsetHeight - heightdifference*2 - distance_font);

		ctx.font = "20px Arial";
		ctx.fillStyle = "grey";
		ctx.fillText("Skillpoints: " + skillpoints, canvas.width-offset_width,canvas.height-offsetHeight - heightdifference*2 - distance_font - 22);

	}

	function drawProjectiles(){
		for (p = 0; p < projectiles.length; p++){

			ctx.save();
			ctx.beginPath();
			ctx.translate(-field_x,-field_y);
			ctx.arc(projectiles[p].x, projectiles[p].y, 5, 0, Math.PI*2);
			ctx.fillStyle = "red";
			ctx.fill();
			ctx.closePath();
			ctx.restore();

		}
	}

	function actProjectiles(){
		for (p = 0; p < projectiles.length; p++){

			projectiles[p].x = projectiles[p].x + (Math.sin(projectiles[p].direction) * projectiles[p].speed * dt);
			projectiles[p].y = projectiles[p].y + (Math.cos(projectiles[p].direction) * projectiles[p].speed * dt);
			projectiles[p].distance = projectiles[p].distance  -  (Math.sqrt(Math.pow(Math.sin(projectiles[p].direction) * projectiles[p].speed * dt,2)
							+ Math.pow(Math.cos(projectiles[p].direction) * projectiles[p].speed * dt ,2)));

			if( projectiles[p].distance < 0){
				projectiles.splice(p,1);
			}

		}
	}

	function shootProjectile(){

		p = { 	x: pos_x + Math.sin(direction) * (taxiHeight+10),
				y: pos_y + Math.cos(direction) * (taxiWidth+10),
				speed: speed + 300,
				direction: direction,
				shooter: myID,
			    distance: 900
		};
		socket.emit("projectile",p);

	}

	function act(){

		actTaxi();
		actTaxis();
		checkCargoHit();
		deliverCargo();
		actProjectiles();
		collisionDetection();

		if(debug) {
			autoPilot();
		}
	}


	function actTaxi(){
		//console.log("pos: " + pos_x + "/" +pos_y + "  velocity: " +velocity.x + "/" + velocity.y);
		//console.log("velocity.value: " + Math.sqrt( Math.pow(velocity.x,2) + Math.pow(velocity.y,2)));
		//console.log("steering_angle: " + steer_angle);

		if (((pos_x + taxiWidth / 2) > fieldwidth) || ((pos_x - taxiWidth / 2) < 0) || ((pos_y + taxiHeight / 2) > fieldheight) || ((pos_y - taxiHeight / 2) < 0)) {

			//alert("Gameover. Points: " + points);
			//document.location.reload();
			lost();
		}

		if (now - spawnTime > 1000) {

			old ={x: pos_x, y: pos_y};

			if ( forwardPressed && speed < max_speed){
				speed = speed + acceleration*dt;
			}
			if(breaking && speed > -max_speed){
				speed = speed - decelaration*dt;
			}

			if (leftPressed){
				steer_angle = Math.min(steer_angle+1.5*dt,0.6);
			}
			else {
				if (rightPressed){
					steer_angle = Math.max(steer_angle-1.5*dt,-0.6);
				}
				else{

					if(steer_angle > 0) {
						steer_angle = steer_angle - 1.5*dt;
						if(steer_angle < 0){
							steer_angle = 0;
						}
					}
					if(steer_angle < 0) {
						steer_angle = steer_angle + 1.5*dt;
						if(steer_angle > 0){
							steer_angle = 0;
						}
					}

					//steer_angle = 0;

				}
			}
			/*
			ctx.save();
			ctx.translate(-field_x,-field_y);

			ctx.beginPath();
			ctx.lineWidth="5";
			ctx.strokeStyle = "pink";
			ctx.moveTo(pos_x,pos_y);
			ctx.lineTo(pos_x + Math.sin(direction+steer_angle)*40, pos_y + Math.cos(direction+steer_angle)*40);
			ctx.stroke();
			ctx.closePath();

			ctx.restore();
			*/
			//console.log("wheels: " + frontWheel.x + "/" + frontWheel.y + "  " + backWheel.x + "/" + backWheel.y);
			/*
			var frontWheelL = {x: pos_x + (taxiHeight/2) * Math.sin(direction) + (taxiWidth/2) * Math.cos(direction),
							y: pos_y + (taxiHeight/2) * Math.cos(direction) + (taxiWidth/2) * Math.sin(direction)};
			var frontWheelR = {x: pos_x + (taxiHeight/2) * Math.sin(direction) - (taxiWidth/2) * Math.cos(direction),
				y: pos_y + (taxiHeight/2) * Math.cos(direction) - (taxiWidth/2) * Math.sin(direction)};
			var backWheelL = {x: pos_x - (taxiHeight/2) * Math.sin(direction) + (taxiWidth/2) * Math.cos(direction),
				y: pos_y - (taxiHeight/2) * Math.cos(direction) + (taxiWidth/2) * Math.sin(direction)};
			var backWheelR = {x: pos_x - (taxiHeight/2) * Math.sin(direction) - (taxiWidth/2) * Math.cos(direction),
				y: pos_y - (taxiHeight/2) * Math.cos(direction) - (taxiWidth/2) * Math.sin(direction)};


			//console.log("wheels: " + frontWheelL.x + "/" + frontWheelL.y + "  " + backWheelL.x + "/" + backWheelL.y);


			frontWheelL.x = frontWheelL.x + speed * dt * Math.sin(direction+steer_angle);
			frontWheelL.y = frontWheelL.y + speed * dt * Math.cos(direction+steer_angle);
			backWheelL.x =  backWheelL.x + speed * dt * Math.sin(direction);
			backWheelL.y = backWheelL.y + speed * dt * Math.cos(direction);
			frontWheelR.x = frontWheelR.x + speed * dt * Math.sin(direction+steer_angle);
			frontWheelR.y = frontWheelR.y + speed * dt * Math.cos(direction+steer_angle);
			backWheelR.x =  backWheelR.x + speed * dt * Math.sin(direction);
			backWheelR.y = backWheelR.y + speed * dt * Math.cos(direction);

			var frontpos = {x: frontWheelL.x - (frontWheelL.x - frontWheelR.x)/2,
							y: frontWheelL.y - (frontWheelL.y - frontWheelR.y)/2};
			var backpos = {x: backWheelL.x - (backWheelL.x - backWheelR.x)/2,
				y: backWheelL.y - (backWheelL.y - backWheelR.y)/2};

			//console.log("wheels: " + frontpos.x + "/" + frontpos.y + "  " + backpos.x + "/" + backpos.y);
			
			pos_x = (frontpos.x + backpos.x)/2;
			pos_y = (frontpos.y + backpos.y)/2;

			direction = Math.atan2((frontpos.x-backpos.x),(frontpos.y-backpos.y));
			*/
			var frontWheel = {x: pos_x + (taxiHeight*(2/5)) * Math.sin(direction),
				y: pos_y + (taxiHeight*(2/5)) * Math.cos(direction)};
			var backWheel = {x: pos_x - (taxiHeight*(2/5)) * Math.sin(direction),
				y: pos_y - (taxiHeight*(2/5)) * Math.cos(direction)};
			//console.log("wheels: " + frontWheel.x + "/" + frontWheel.y + "  " + backWheel.x + "/" + backWheel.y);
			
			driftingFriction = 0.2;
			if(drifting) {
				driftangle = 0;
				if (leftPressed){
					driftangle = -Math.PI/2;
					
				}else if (rightPressed) {
					driftangle = +Math.PI/2;
				}
				driftForce_x=0;
				driftForce_y=0;
				if(driftangle != 0) {
					driftForce_x = speed*driftingFriction * dt * Math.sin(direction+steer_angle);
					driftForce_y = speed*driftingFriction * dt * Math.cos(direction+steer_angle+driftangle);
				}
				backWheel.x =  backWheel.x + speed * dt * Math.sin(direction) + driftForce_x;
				backWheel.y = backWheel.y + speed* dt * Math.cos(direction) + driftForce_y;
				frontWheel.x = frontWheel.x + speed* dt * Math.sin(direction+steer_angle);
				frontWheel.y = frontWheel.y + speed * dt * Math.cos(direction+steer_angle);
			} else {
				frontWheel.x = frontWheel.x + speed * dt * Math.sin(direction+steer_angle);
				frontWheel.y = frontWheel.y + speed * dt * Math.cos(direction+steer_angle);
				backWheel.x =  backWheel.x + speed * dt * Math.sin(direction);
				backWheel.y = backWheel.y + speed * dt * Math.cos(direction);
			}
			pos_x = (frontWheel.x + backWheel.x)/2;
			pos_y = (frontWheel.y + backWheel.y)/2;
			direction = Math.atan2((frontWheel.x-backWheel.x),(frontWheel.y-backWheel.y));

		}
	}

	function actTaxis(){
		for (var t = 0; t < taxis.length; t++) {
			if(taxis[t].id != myID) {
				if (taxis[t].leftPressed){
					taxis[t].direction = (((taxis[t].direction+(turningSpeed*dt))+Math.PI)%(2*Math.PI))-Math.PI;
				}
				if (taxis[t].rightPressed){
					if( (taxis[t].direction-(0.5*dt)) < (-Math.PI) ){
						taxis[t].direction = (taxis[t].direction-(turningSpeed*dt))+2*Math.PI;
					}
					else{
						taxis[t].direction = (((taxis[t].direction-(turningSpeed*dt))+Math.PI)%(2*Math.PI))-Math.PI;
					}
				}

				taxis[t].pos_x = taxis[t].pos_x + Math.sin(taxis[t].direction)*dt*taxis[t].speed;
				taxis[t].pos_y = taxis[t].pos_y + Math.cos(taxis[t].direction)*dt*taxis[t].speed;
			}
		}
	}

	function reset(){


		var valid_pos = false;
		while(!valid_pos){

			valid_pos = true;

			pos_x = Math.floor((Math.random() * (canvas.width-80)) + 40);
			pos_y = Math.floor((Math.random() * (canvas.height-80)) + 40);

			var c1 = rotatePoint([pos_x,pos_y], [pos_x+taxiWidth/2, pos_y+taxiHeight/2],direction);
			var c2 = rotatePoint([pos_x,pos_y], [pos_x+taxiWidth/2, pos_y-taxiHeight/2],direction);
			var c3 = rotatePoint([pos_x,pos_y], [pos_x-taxiWidth/2, pos_y+taxiHeight/2],direction);
			var c4 = rotatePoint([pos_x,pos_y], [pos_x-taxiWidth/2, pos_y-taxiHeight/2],direction);
			var mycorners = [
				{ 	x: c1[0],
					y: c1[1]
				},
				{ 	x: c2[0],
					y: c2[1]
				},
				{ 	x: c3[0],
					y: c3[1]
				},
				{ 	x: c4[0],
					y: c4[1]
				}
			];

			for(var h=0; h < houses.length; h++){

				var collision = doPolygonsIntersect(mycorners,houses[h]);
				if(collision){
					valid_pos = false;
				}

			}

		}

		field_x = 0;
		field_y = 0;

		passengers = 0;
        passengersList = [];

		direction = 0; // -PI to +Pi
		speed = 0;
		max_speed = 180;

		taxilevel = 0;
		max_passengers = getTaxiConfig(taxilevel).max_passengers;
		taxiWidth = getTaxiConfig(taxilevel).taxiWidth;
		taxiHeight = getTaxiConfig(taxilevel).taxiHeight;
		taxisize = 0

		handlingLevel = 0;
		turningSpeed = getHandling(handlingLevel);
		points = 0;
		spawnTime = Date.now();

		level = 0;
		experience = 0;
		skillpoints = 0;

		taxiConfig = getTaxiConfig(taxisize);

		steer_angle = 0;

		forwardPressed = false;
		leftPressed = false;
		rightPressed = false;
		breaking = false;

	}

	function lost(){
		speed = 0;
		acceleration = 0;
		//socket.emit("GameOver",{points:points, id:myID,name:name});
		//reset();
	}

	function checkCargoHit(){
		for (var c = 0; c<cargo.length; c++){
			if (cargo[c].x < pos_x+taxiWidth/2 && cargo[c].x > pos_x - taxiWidth/2){
				if (cargo[c].y < pos_y+taxiHeight/2 && cargo[c].y > pos_y - taxiHeight/2){
					if(addCargo(c)){
						cargo.splice(c,1);
						socket.emit("cargo",c);
					}
				}
			}
		}
	}

	function addCargo(c){
		if( passengers < max_passengers){
			passengers = passengers + 1;
			passengersList[passengersList.length] = cargo[c];
			return true;
		}
		return false;
	}

	function deliverCargo(){


		var c1 = rotatePoint([pos_x,pos_y], [pos_x+((taxiWidth/2) -5), pos_y+((taxiHeight/2) - 5)],direction);
		var c2 = rotatePoint([pos_x,pos_y], [pos_x+((taxiWidth/2) -5), pos_y-((taxiHeight/2) - 5)],direction);
		var c3 = rotatePoint([pos_x,pos_y], [pos_x-((taxiWidth/2) -5), pos_y+((taxiHeight/2) - 5)],direction);
		var c4 = rotatePoint([pos_x,pos_y], [pos_x-((taxiWidth/2) -5), pos_y-((taxiHeight/2) - 5)],direction);
		var mycorners = [
			{ 	x: c1[0],
				y: c1[1]
			},
			{ 	x: c2[0],
				y: c2[1]
			},
			{ 	x: c3[0],
				y: c3[1]
			},
			{ 	x: c4[0],
				y: c4[1]
			}
		];

		for(b=0; b < bases.length; b++){

			var collision = doPolygonsIntersect(mycorners,bases[b].form);
			if(collision){
				var remove = [];
				for( p = 0; p < passengersList.length; p++){

					if(passengersList[p].color == bases[b].color){
						max_speed = max_speed + speed_gain;
						points++;
						experience++;
						while( experience >= getExperience(level)){
							experience -= getExperience(level);
							level++;
							skillpoints++;
						}
						passengers--;
						remove[remove.length] = p;
					}
				}
				for(r = 0; r < remove.length; r++){
					passengersList.splice(remove[r],1);
				}
			}
		}
		/*
		if(pos_x < base.x + base.radius && pos_x > base.x - base.radius ){
			if(pos_y < base.y + base.radius && pos_y > base.y - base.radius ) {
				max_speed = max_speed + speed_gain * passengers;
				points = points + passengers;
				experience += passengers;
				while( experience >= getExperience(level)){
					experience -= getExperience(level);
					level++;
					skillpoints++;
				}
				if (passengers > 0) {
					//upgradeTaxi();
				}
				passengers = 0;
			}
		}
		*/

	}

	function getExperience(level){
		switch(level){
			case 0:
				return 1;
			case 1:
				return 2;
			case 2:
				return 3;
		}
		return 5;
	}

	function getHandling(handlingLevel){
		switch(handlingLevel){
			case 0:
				return 3;
			case 1:
				return 3.5;
			case 2:
				return 4;
			case 3:
				return 4.5;
			case 4:
				return 5;
			case 5:
				return 5.5;
		}
		return 3;
	}

	function getTaxiConfig(taxilevel){
		var configuration = {	passenger_offset_x:[],
			passenger_offset_y:[],
			pilot_x:0, pilot_y:0,
			max_passengers:1, taxiWidth:15,
			taxiHeight:30
		};
		switch(taxilevel){
			case 0:
				configuration.passenger_offset_x = [0];
				configuration.passenger_offset_y = [-4];
				configuration.pilot_x = 0;
				configuration.pilot_y = 4;
				break;
			case 1:
				configuration.passenger_offset_x = [-3,3];
				configuration.passenger_offset_y = [-4,-4];
				configuration.pilot_x = 0;
				configuration.pilot_y = 4;
				configuration.max_passengers = 2;
				configuration.taxiWidth = 20;
				configuration.taxiHeight = 30;
				break;
			case 2:
				configuration.passenger_offset_x = [-3,3,-3,3];
				configuration.passenger_offset_y = [0,0,-8,-8];
				configuration.pilot_x = 0;
				configuration.pilot_y = 8;
				configuration.max_passengers = 4;
				configuration.taxiWidth = 20;
				configuration.taxiHeight = 35;
				break;
			case 3:
				configuration.passenger_offset_x = [-3,3,-3,3,-3,3];
				configuration.passenger_offset_y = [3,3,-5,-5,-13,-13];
				configuration.pilot_x = 0;
				configuration.pilot_y = 13;
				configuration.max_passengers = 6;
				configuration.taxiWidth = 22;
				configuration.taxiHeight = 40;
				break;
			case 4:
				configuration.passenger_offset_x = [0,6,-6,0,6,-6,0,6,-6];
				configuration.passenger_offset_y = [3,3,3,-5,-5,-5,-13,-13,-13];
				configuration.pilot_x = 0;
				configuration.pilot_y = 13;
				configuration.max_passengers = 9;
				configuration.taxiWidth = 30;
				configuration.taxiHeight = 40;
				break;
			case 5:
				configuration.passenger_offset_x = [0,6,-6,0,6,-6,0,6,-6,0,6,-6];
				configuration.passenger_offset_y = [8,8,8,0,0,0,-8,-8,-8,-16,-16,-16];
				configuration.pilot_x = 0;
				configuration.pilot_y = 18;
				configuration.max_passengers = 12;
				configuration.taxiWidth = 30;
				configuration.taxiHeight = 50;
				break;
			case 6:
				configuration.passenger_offset_x = [0,6,-6,0,6,-6,0,6,-6,0,6,-6,0,6,-6];
				configuration.passenger_offset_y = [13,13,13,5,5,5,-3,-3,-3,-11,-11,-11,-19,-19,-19];
				configuration.pilot_x = 0;
				configuration.pilot_y = 23;
				configuration.max_passengers = 15;
				configuration.taxiWidth = 33;
				configuration.taxiHeight = 60;
				break;
			case 7:
			case 8:
			case 9:
			case 10:
			case 11:
		}
		return configuration;
	}

	function keyDownHandler(e) {
		if(e.keyCode == 39) {
			rightPressed = true;
		}
		else if(e.keyCode == 37) {
			leftPressed = true;
		}
		else if(e.keyCode == 38) {
			forwardPressed = true;
		}
		else if(e.keyCode == 68) {
			debug = !debug;
		}
		else if(e.keyCode == 70) {
			autoPilotturningSpeed++;
		}
		else if(e.keyCode == 51) {
			if(skillpoints > 0) {
				if (handlingLevel < handlingLevel_max) {
					handlingLevel++;
					turningSpeed = getHandling(handlingLevel);
					skillpoints--;
				}
			}
		}
		else if(e.keyCode == 50) {
			if(skillpoints > 0) {
				if (brakelevel < brakelevel_max) {
					brakelevel++;

					decelaration = decelaration+30;
					skillpoints--;
				}
			}
		}
		else if(e.keyCode == 49) {
			if(skillpoints > 0) {
				if (taxilevel < taxilevel_max) {
					taxilevel++;

					taxiConfig = getTaxiConfig(taxilevel);
					max_passengers = getTaxiConfig(taxilevel).max_passengers;
					taxiWidth = getTaxiConfig(taxilevel).taxiWidth;
					taxiHeight = getTaxiConfig(taxilevel).taxiHeight;

					skillpoints--;
				}
			}
		}
		else if(e.keyCode == 40) {
			breaking = true;
		}
		else if(e.keyCode == 17) {
			if (now - lastShot > 1000){
				shootProjectile();
				lastShot = now;
			}
		}
		else if(e.keyCode == 32) {
			drifting = true;
		}
		//console.log("key: " + e.keyCode);
	}

	function keyUpHandler(e) {
		if(e.keyCode == 39) {
			rightPressed = false;
		}
		else if(e.keyCode == 37) {
			leftPressed = false;
		}
		else if(e.keyCode == 40) {
			breaking = false;
		}
		else if(e.keyCode == 38) {
			forwardPressed = false;
		}
		else if(e.keyCode == 32) {
			drifting = false;

		}
	}

	function logger(){

		if(now - lastLogged > logInterval ){
			lastLogged = now;
			//console.log("field: " +field_x+"/" + field_y);
			//console.log("window: " +window.innerWidth+"/" + window.innerHeight);
		}

	}

	function collissionHandlingHouses(id){

		//find collision side
		var smallest_distance = 10000;
		var smallest_distance_1 = -1;
		var smallest_distance_2 = -1;
		for(i = 0; i < houses[id].length; i++ ) {


			var r1 = { x: houses[id][i].x, y: houses[id][i].y};
			var a = {
				x: (houses[id][i].x - houses[id][(i+1)%(houses[id].length)].x),
				y: (houses[id][i].y - houses[id][(i+1)%(houses[id].length)].y)
			};
			var rq = { x: pos_x+Math.sin(direction)*taxiHeight/2, y:pos_y+Math.cos(direction)*taxiHeight/2};

			var b = { x: rq.x - r1.x, y: rq.y - r1.y};
			var cross = a.x*b.y  - b.x * a.y;

			//var top = Math.sqrt( Math.pow(cross,2) + Math.pow(cross.y,2) );
			var top = Math.abs(cross);
			var down = Math.sqrt( Math.pow(a.x,2) + Math.pow(a.y,2));

			//console.log("top: " +top);
			//console.log("down: " +down);

			var distance = top/down;
			/*
			ctx.save();
			ctx.translate(-field_x,-field_y);

			ctx.beginPath();
			ctx.lineWidth="5";
			ctx.strokeStyle = "pink";
			ctx.moveTo(rq.x,rq.y);
			ctx.lineTo(rq.x + Math.sin(Math.atan2(-a.y,a.x))*distance, rq.y + Math.cos(Math.atan2(-a.y, a.x))*distance );
			ctx.stroke();
			ctx.closePath();

			ctx.restore();
			*/
			/*
			var A = houses[id][i];
			var B = houses[id][(i+1)%(houses[id].length)];

			var n_x =  -(A.y+B.y);
			var n_y = (A.x+B.x);

			var distance = Math.abs((n_x)*(pos_x) + (n_y)*(pos_y)) / Math.sqrt( Math.pow((n_x),2) + Math.pow((n_y),2));
			*/
			//console.log("distance: " + distance);
			//console.log("distance: " + distance);
			//console.log("pos: " + pos_x + "/" + pos_y + "line_center: " + line_center.x + "/" + line_center.y + "corners: " + houses[id][i].x + "/" + houses[id][i].y + "  " + houses[id][(i+1)%(houses[id].length-1)].x + "/" + houses[id][(i+1)%(houses[id].length-1)].y);

			if(smallest_distance > distance){
				smallest_distance = distance;
				if(i == (houses[id].length-1) ){
					smallest_distance_1 = i;
					smallest_distance_2 = (i+1)%(houses[id].length);
				}
				else {
					smallest_distance_2 = i;
					smallest_distance_1 = (i + 1) % (houses[id].length);
				}
			}

		}
		//console.log("smallest distance: " + smallest_distance);


		//find collision angle

		var old_steering = steer_angle;
		//direction = Math.atan2( houses[id][smallest_distance_1].x - houses[id][smallest_distance_2].x, houses[id][smallest_distance_1].y - houses[id][smallest_distance_2].y );
		//console.log("direction: " + direction + "+atan2:" + (Math.atan2( houses[id][smallest_distance_1].x - houses[id][smallest_distance_2].x, houses[id][smallest_distance_1].y - houses[id][smallest_distance_2].y ) )
					//+ " -atan: " + (Math.atan2( houses[id][smallest_distance_2].x - houses[id][smallest_distance_1].x, houses[id][smallest_distance_2].y - houses[id][smallest_distance_1].y )));
		var atan1 = (Math.atan2( houses[id][smallest_distance_1].x - houses[id][smallest_distance_2].x, houses[id][smallest_distance_1].y - houses[id][smallest_distance_2].y ) );
		var atan2 = (Math.atan2( houses[id][smallest_distance_2].x - houses[id][smallest_distance_1].x, houses[id][smallest_distance_2].y - houses[id][smallest_distance_1].y ) );
		var between1 = Math.min( 2*Math.PI - Math.abs(direction-atan1), Math.abs(direction-atan1) );
		var between2 = Math.min( 2*Math.PI - Math.abs(direction-atan2), Math.abs(direction-atan2) );
		if( between1 <  between2){
			pos_x = old.x;
			pos_y = old.y;

			speed = speed * Math.cos(between1)

			pos_x = pos_x + Math.sin(atan1)*speed*dt;
			pos_y = pos_y + Math.cos(atan1)*speed*dt;


		}else{
			pos_x = old.x;
			pos_y = old.y;

			speed = speed * Math.cos(between2)

			pos_x = pos_x + Math.sin(atan2)*speed*dt;
			pos_y = pos_y + Math.cos(atan2)*speed*dt;
		}
		//actTaxi();
		//console.log("angle: " + direction);

		//speed = 20;



	}

	function collisionDetection(){
		/*
		var c1 = rotatePoint([pos_x,pos_y], [pos_x+((taxiWidth/2) -0), pos_y+((taxiHeight/2) - 0)],direction);
		var c2 = rotatePoint([pos_x,pos_y], [pos_x+((taxiWidth/2) -0), pos_y-((taxiHeight/2) - 0)],direction);
		var c3 = rotatePoint([pos_x,pos_y], [pos_x-((taxiWidth/2) -0), pos_y+((taxiHeight/2) - 0)],direction);
		var c4 = rotatePoint([pos_x,pos_y], [pos_x-((taxiWidth/2) -0), pos_y-((taxiHeight/2) - 0)],direction);
		*/
		var c1 = [ pos_x + (taxiHeight/2) * Math.sin(direction) + (taxiWidth/2) * Math.cos(direction),
			 pos_y + (taxiHeight/2) * Math.cos(direction) + (taxiWidth/2) * Math.sin(direction)];
		var c2 = [ pos_x + (taxiHeight/2) * Math.sin(direction) - (taxiWidth/2) * Math.cos(direction),
			 pos_y + (taxiHeight/2) * Math.cos(direction) - (taxiWidth/2) * Math.sin(direction)];
		var c3 = [ pos_x - (taxiHeight/2) * Math.sin(direction) + (taxiWidth/2) * Math.cos(direction),
			 pos_y - (taxiHeight/2) * Math.cos(direction) + (taxiWidth/2) * Math.sin(direction)];
		var c4 = [ pos_x - (taxiHeight/2) * Math.sin(direction) - (taxiWidth/2) * Math.cos(direction),
			 pos_y - (taxiHeight/2) * Math.cos(direction) - (taxiWidth/2) * Math.sin(direction)];
		var mycorners = [
			{ 	x: c1[0],
				y: c1[1]
			},
			{ 	x: c2[0],
				y: c2[1]
			},
			{ 	x: c3[0],
				y: c3[1]
			},
			{ 	x: c4[0],
				y: c4[1]
			}
		];

		for(t=0; t < taxis.length; t++){

			if(taxis[t].id != myID){				

				var d1 = rotatePoint([taxis[t].pos_x,taxis[t].pos_y], [taxis[t].pos_x+taxis[t].taxiWidth/2, taxis[t].pos_y+taxis[t].taxiHeight/2],taxis[t].direction);
				var d2 = rotatePoint([taxis[t].pos_x,taxis[t].pos_y], [taxis[t].pos_x+taxis[t].taxiWidth/2, taxis[t].pos_y-taxis[t].taxiHeight/2],taxis[t].direction);
				var d3 = rotatePoint([taxis[t].pos_x,taxis[t].pos_y], [taxis[t].pos_x-taxis[t].taxiWidth/2, taxis[t].pos_y+taxis[t].taxiHeight/2],taxis[t].direction);
				var d4 = rotatePoint([taxis[t].pos_x,taxis[t].pos_y], [taxis[t].pos_x-taxis[t].taxiWidth/2, taxis[t].pos_y-taxis[t].taxiHeight/2],taxis[t].direction);
				var othercorners = [
					{ 	x: d1[0],
						y: d1[1]
					},
					{ 	x: d2[0],
						y: d2[1]
					},
					{ 	x: d3[0],
						y: d3[1]
					},
					{ 	x: d4[0],
						y: d4[1]
					}
				];

				var collision = doPolygonsIntersect(mycorners,othercorners);
				if(collision){
					lost();
				}

			}

		}

		for(h=0; h < houses.length; h++){

			var collision = doPolygonsIntersect(mycorners,houses[h]);
			if(collision){
				collissionHandlingHouses(h);
				//lost();
			}
		}

		for( p = 0; p < projectiles.length; p++){
			if( Math.sqrt(Math.pow(projectiles[p].x - pos_x,2) + Math.pow(projectiles[p].y - pos_y,2)) < (2+taxiWidth/2) ) {
				if (projectiles[p].shooter != myID) {
					lost();
				}
			}
		}

	}

	function rotatePoint(pivot, point, angle) {
		// Rotate clockwise, angle in radians
		var x = Math.round((Math.cos(angle) * (point[0] - pivot[0])) -
						(Math.sin(angle) * (point[1] - pivot[1])) +
						pivot[0]),
				y = Math.round((Math.sin(angle) * (point[0] - pivot[0])) +
						(Math.cos(angle) * (point[1] - pivot[1])) +
						pivot[1]);
		return [x, y];
	}

	/**
	 * Helper function to determine whether there is an intersection between the two polygons described
	 * by the lists of vertices. Uses the Separating Axis Theorem
	 *
	 * @param a an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon
	 * @param b an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon
	 * @return true if there is any intersection between the 2 polygons, false otherwise
	 */
	function doPolygonsIntersect (a, b) {
		var polygons = [a, b];
		var minA, maxA, projected, i, i1, j, minB, maxB;

		for (i = 0; i < polygons.length; i++) {

			// for each polygon, look at each edge of the polygon, and determine if it separates
			// the two shapes
			var polygon = polygons[i];
			for (i1 = 0; i1 < polygon.length; i1++) {

				// grab 2 vertices to create an edge
				var i2 = (i1 + 1) % polygon.length;
				var p1 = polygon[i1];
				var p2 = polygon[i2];

				// find the line perpendicular to this edge
				var normal = { x: p2.y - p1.y, y: p1.x - p2.x };

				minA = maxA = undefined;
				// for each vertex in the first shape, project it onto the line perpendicular to the edge
				// and keep track of the min and max of these values
				for (j = 0; j < a.length; j++) {
					projected = normal.x * a[j].x + normal.y * a[j].y;
					if ((minA == undefined) || projected < minA) {
						minA = projected;
					}
					if ((maxA == undefined) || projected > maxA) {
						maxA = projected;
					}
				}

				// for each vertex in the second shape, project it onto the line perpendicular to the edge
				// and keep track of the min and max of these values
				minB = maxB = undefined;
				for (j = 0; j < b.length; j++) {
					projected = normal.x * b[j].x + normal.y * b[j].y;
					if ((minB == undefined) || projected < minB) {
						minB = projected;
					}
					if ((maxB == undefined) || projected > maxB) {
						maxB = projected;
					}
				}

				// if there is no overlap between the projects, the edge we are looking at separates the two
				// polygons, and we know there is no overlap
				if (maxA < minB || maxB < minA) {
					//CONSOLE("polygons don't intersect!");
					return false;
				}
			}
		}
		return true;
	}

	</script>	
	
  </body>
</html>
