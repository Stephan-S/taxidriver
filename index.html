<!doctype html>
<html>
  <head>
    <title>Socket.IO chat</title>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      body { font: 13px Helvetica, Arial;  overflow: hidden; }
      form { background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; }
      form input { border: 0; padding: 10px; width: 90%; margin-right: .5%; }
      form button { width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; }
      #messages { list-style-type: none; margin: 0; padding: 0; }
      #messages li { padding: 5px 10px; }
      #messages li:nth-child(odd) { background: #eee; }
    </style>
  </head>
  <body>

	<script src="/socket.io/socket.io.js"></script>
	
	<canvas id="myCanvas" width="1280" height="720"></canvas>

	<script>
	"use strict";
	var canvas = document.getElementById("myCanvas");
	var ctx = canvas.getContext("2d");
	ctx.canvas.width  = window.innerWidth;
	ctx.canvas.height = window.innerHeight;

	var taxisize = 0;
	var taxiWidth = 15;
	var taxiHeight = 34;
	var passengers = 0;
	var max_passengers = 1;
	var passenger_offset_x = [0,6,-6,0,6,-6,0,6,-6,0,6,-6];
	var passenger_offset_y = [-4,-4,-4,-12,-12,-12,-20,-20,-20,-28,-28,-28];
	var taxiConfig = getTaxiConfig(taxisize);

	var handlingLevel = 0;
	var handlingLevel_max = 5;
	var taxilevel = 0;
	var taxilevel_max = 6;
	var turningSpeed = getHandling(handlingLevel);
	var autoPilotturningSpeed = 8;
	var pos_x = Math.floor((Math.random() * (canvas.width-100)) + 50);
	var pos_y = Math.floor((Math.random() * (canvas.height-100)) + 50);
	var points = 0;
	var min_viewdistance = 500;
	var highscore = 0;
	var highscore_name = "NoOne";
	var name = "Player1";
	var myID = Math.floor((Math.random() * 1000)) + 1;
	var fieldwidth = 4000;
	var fieldheight = 4000;
	var chunksize = 400;
	var streetsize = 60;
	var bordersize = 120;
	var field_x = 0;
	var field_y = 0;
	var connected = false;
	var taxis = [];
	var houses = [];
	var bases = [];
	var traffic = [];
	var mapData = ctx.getImageData(0,0,fieldwidth, fieldheight);
	var passengersList = [];
	var now = Date.now();
	var time = now;
	var spawnTime = now;
	var lastCargo = now;
	var lastLogged = now;
	var lastShot = now;
	var logInterval = 500;
	var dt = 0;
	var cargo = [];
	var base = { x:75, y:75, radius:75};
	var rightPressed = false;
	var leftPressed = false;
	var forwardPressed = false;
	var socket = io();
	var debug = false;
	var target = {x:-1,y:-1};
	var level = 0;
	var experience = 0;
	var skillpoints = 0;
	var brakelevel = 0;
	var brakelevel_max = 5;
	var decelaration = 80;
	var breaking = false;
	var drifting = false;
	var max_turning_speed = 8;
	var projectiles = [];
	var taxiImage = new Image();
	taxiImage.src = "/img/taxi.png";
	taxiImage.onload = function() {
		ctx.drawImage(taxiImage,0,0);
	};
	
	var steer_angle = 0;
	var steer_factor = 3;
	var direction = 0; // -PI to +Pi
	var speed = 0;
	var max_speed = 180;
	var speed_gain = 10;
	var acceleration = 80;
	var old = {x:100,y:100};
	var health = 100;
	var health_max = 100;
	var health_regen = 5;
	var friction = 35;
	var max_turning_angle = 0.6;

	let speedlevel = 0;
	var speedlevel_max = 5;
	let pause = false;

	ctx.font = "10px Arial";

	socket.on('data', function(servercargo){
		cargo = servercargo;
	});

	socket.on('taxis', function(servertaxis){
		taxis = servertaxis;
	});

	socket.on('projectiles', function(serverprojectiles){
		projectiles = serverprojectiles;
	});

	socket.on('map', function(map){
		fieldwidth = map.fieldwidth;
		fieldheight = map.fieldheight;
		chunksize = map.chunksize;
		streetsize = map.streetsize;
		bordersize = map.bordersize;
		
		ctx.canvas.width  = fieldwidth;
		ctx.canvas.height = fieldheight;
		
		console.log("Getting houses");
		houses = map.houses;
		console.log(houses);
		console.log("Getting bases:")
		bases = map.bases;
		console.log(bases);
		drawOnce();
		createWaypoints();
		reset();
		draw();

		ctx.canvas.width  = window.innerWidth;
		ctx.canvas.height = window.innerHeight;
	}); 
	
  	socket.on('bases', function(serverbases){

		console.log("Getting bases:")
	     bases = serverbases;
	  });

	socket.on('score', function(score){
		highscore = score.highscore;
		highscore_name = score.name;
	});

	socket.on('traffic', function(servertraffic){
		traffic = servertraffic;
	})

	document.addEventListener("keydown", keyDownHandler, false);
	document.addEventListener("keyup", keyUpHandler, false);


	var found_street = false;
	var auto_speed = 100;
	var angle_override = 0;
	var target_waypoint = -1;

	function autoPilot(){

		if(target_waypoint == -1){
			let mindistance = -1;
			target_waypoint = -1;
			for(let x = 0; x < waypoints.length; x++){
				let between = Math.min( 2*Math.PI - Math.abs(direction-waypoints[x].direction), Math.abs(direction-waypoints[x].direction) );

				if( (( (Math.sin(between) > 0)) && (Math.sqrt(Math.pow( pos_x - waypoints[x].x,2) + Math.pow(pos_y - waypoints[x].y,2)) < mindistance)) || (mindistance == -1)  ){

					mindistance = (Math.sqrt(Math.pow( pos_x - waypoints[x].x,2) + Math.pow(pos_y - waypoints[x].y,2)));
					target_waypoint = x;
					console.log("Waypoint found: " + waypoints[target_waypoint].x + "/" + waypoints[target_waypoint].y + "  distance: " + mindistance + " angle: " + between);

				}
			}
			console.log("Waypoint found: " + waypoints[target_waypoint].x + "/" + waypoints[target_waypoint].y + " angle: " +Math.min( 2*Math.PI - Math.abs(direction-waypoints[target_waypoint].direction), Math.abs(direction-waypoints[target_waypoint].direction) ));
		}

		if(target_waypoint != -1){

			let mindistance = (Math.sqrt(Math.pow( pos_x - waypoints[target_waypoint].x,2) + Math.pow(pos_y - waypoints[target_waypoint].y,2)));
			if( mindistance < 15 ){
				target_waypoint = waypoints[target_waypoint].connections[ Math.floor((Math.random() * (waypoints[target_waypoint].connections.length)))];
			}

			leftPressed = false;
			rightPressed = false;
			var crossProduct = Math.sin(direction) * (pos_y - waypoints[target_waypoint].y) - ( Math.cos(direction) * (pos_x - waypoints[target_waypoint].x)  );
			if (Math.abs(crossProduct) > 0.2) {
				if (crossProduct > 0){
					steer_angle = Math.min(steer_angle+5*dt, max_turning_angle / (Math.max(100,Math.abs(speed))/100) );
				}
				else {
					if (crossProduct < 0){
						steer_angle = Math.max(steer_angle-5*dt,- (max_turning_angle / (Math.max(100,Math.abs(speed))/100)) );
					}
				}
			}
			else {
				steer_angle = 0;
			}

			let between = -Math.min( 2*Math.PI - Math.abs(direction- Math.atan2( waypoints[target_waypoint].x - pos_x, waypoints[target_waypoint].y -pos_y )),
					Math.abs(direction- Math.atan2(waypoints[target_waypoint].x -  pos_x, waypoints[target_waypoint].y -pos_y )) )

			console.log("steer_angle before: " + steer_angle);
			if ( Math.abs(between) < Math.abs(steer_angle) && ((between*steer_angle) >= 0 )){
				console.log("limiting steering");
				steer_angle = between;

				//stop();

			}
			console.log("angle to target: " + between + " steer_angle: " + steer_angle);


			if (speed < 90) {
				forwardPressed = true;
			}
			else {
				forwardPressed = false;
			}

		}

	}


	let stop = () => {
			pause = true;
	}

	var waypoints = [];
	function createWaypoints(){

		for(let xId=0;xId<maxChunksX;xId++){
			for(let yId=0;yId<maxChunksY;yId++) {

				let xCh = bordersize + xId * chunksize;
				let yCh = bordersize + yId * chunksize;

				waypoints[waypoints.length] = {x: xCh + streetsize/2, y: yCh + chunksize - streetsize, direction: Math.PI, id: 0, matching: [1]};
				waypoints[waypoints.length] = {x: xCh + streetsize/2, y: yCh + streetsize , direction: Math.PI, id: 1, matching: [0,2,6]};
				waypoints[waypoints.length] = {x: xCh + streetsize, y: yCh + streetsize/2 , direction: Math.PI/2, id:2 , matching: [3]};
				waypoints[waypoints.length] = {x: xCh + chunksize - streetsize, y: yCh + streetsize/2, direction: Math.PI/2 ,id: 3, matching: [0,2,4]};
				waypoints[waypoints.length] = {x: xCh + chunksize - streetsize/2, y: yCh + streetsize, direction:0 ,id:4 , matching: [5]};
				waypoints[waypoints.length] = {x: xCh + chunksize - streetsize/2, y: yCh + chunksize - streetsize , direction: 0, id:5, matching: [2,4,6]};
				waypoints[waypoints.length] = {x: xCh + chunksize - streetsize, y: yCh + chunksize - streetsize/2, direction: -Math.PI/2, id:6 ,  matching: [7] };
				waypoints[waypoints.length] = {x: xCh + streetsize, y: yCh + chunksize - streetsize/2, direction: -Math.PI/2, id: 7,matching: [0,4,6] };
			}
		}
		let wp_distance = -1;
		for(let x = 0; x < waypoints.length; x++){
				let w1 = waypoints[x];
				w1.connections = [];
			//console.log("wp: " + w1.x + "/" + w1.y);
			for(let y = 0; y < waypoints.length; y++){
				let w2 = waypoints[y];
				wp_distance = distanceP(w1,w2);
				let between = Math.min( 2*Math.PI - Math.abs(w1.direction-w2.direction), Math.abs(w1.direction-w2.direction) );

				let minWpDistance = 0;
				let maxWpDistance = 0;
				if( [0,2,4,6].includes(w1.id) ){
					minWpDistance = chunksize/2;
					maxWpDistance = chunksize - streetsize;
				}
				else{
					minWpDistance = 5;
					maxWpDistance = 2*streetsize + 15;
				}

				if( (x != y) && (wp_distance < maxWpDistance) && (wp_distance > minWpDistance) && w1.matching.includes(w2.id) /*&& (between <= Math.PI/2)*/ ){
					w1.connections[w1.connections.length] = y;
					//console.log("	connected: " + w2.x + "/" + w2.y);
				}


			}

		}

	}

	function distanceC(x1,y1,x2,y2){
		return Math.sqrt(Math.pow(x1-x2,2) + Math.pow(y1-y2,2));
	}

	function distanceP(x,y){
		return Math.sqrt(Math.pow(x.x-y.x,2) + Math.pow(x.y-y.y,2));
	}


	function drawWaypoints(){

		for(let x = 0; x < waypoints.length; x++){
			ctx.save();
			ctx.translate(waypoints[x].x, waypoints[x].y);
			ctx.translate(-field_x,-field_y);
			ctx.beginPath();
			ctx.fillStyle = "red";
			ctx.arc(0, 0, 8, 0, 2 * Math.PI);

			ctx.fill();

			ctx.beginPath();
			ctx.lineWidth="5";
			ctx.strokeStyle = "red";
			ctx.moveTo(0,0 );
			ctx.lineTo( Math.sin(waypoints[x].direction)*30,Math.cos(waypoints[x].direction)*30 );
			ctx.stroke();
			ctx.closePath();


			for(let i = 0; i < waypoints[x].connections.length; i++){
				ctx.beginPath();
				ctx.lineWidth="5";
				ctx.strokeStyle = "blue";
				ctx.moveTo(0,0 );
				ctx.lineTo( waypoints[ waypoints[x].connections[i] ].x - waypoints[x].x, waypoints[ waypoints[x].connections[i] ].y - waypoints[x].y );
				ctx.stroke();
				ctx.closePath();

			}


			ctx.restore();
		}

	}


	function autoPilotGoToTarget() {

		var crossProduct = Math.sin(direction) * (pos_y - target.y) - ( Math.cos(direction) * (pos_x - target.x)  );
		if (Math.abs(crossProduct) > 1) {

			if (crossProduct > 0) {

				direction = (((direction + (2 * autoPilotturningSpeed * dt)) + Math.PI) % (2 * Math.PI)) - Math.PI;
				crossProduct = Math.sin(direction) * (pos_y - target.y) - ( Math.cos(direction) * (pos_x - target.x)  );
				if (crossProduct < 0) {
					direction = Math.atan2(target.x-pos_x,target.y-pos_y);
				}
			}
			else {
				if ((direction - (0.5 * dt)) < (-Math.PI)) {
					direction = (direction - (2 * autoPilotturningSpeed * dt)) + 2 * Math.PI;
				}
				else {
					direction = (((direction - (2 * autoPilotturningSpeed * dt)) + Math.PI) % (2 * Math.PI)) - Math.PI;
				}

				crossProduct = Math.sin(direction) * (pos_y - target.y) - ( Math.cos(direction) * (pos_x - target.x)  );
				if (crossProduct > 0) {
					direction = Math.atan2(target.x-pos_x,target.y-pos_y);
				}
			}
		}


	}
	
	function baseArrow(baseNumber){
		
		var targetBase = bases[baseNumber];
		ctx.save();
		ctx.translate(-field_x,-field_y);
		
		ctx.beginPath();
		ctx.lineWidth="5";
		switch(targetBase.color) {
			case 0:
				ctx.fillStyle = "red";
				break;
			case 1:
				ctx.fillStyle = "pink";
				break;
			case 2:
				ctx.fillStyle = "yellow";
				break;
			case 3:
				ctx.fillStyle = "green";
				break;
			case 4:
				ctx.fillStyle = "blue";
				break;
			default:
				ctx.fillStyle = "green";
				break;
		}
		
		//Determine Center of base
		let center = determineCenterOfPolygon(targetBase.form);
		let x = center.x;
		let y = center.y;
		
		//Determine angle to center of base
		var angle = Math.atan2(x-pos_x, y -pos_y);
		
		ctx.moveTo(pos_x,pos_y);		
		ctx.moveTo(pos_x + Math.sin(angle)*30, pos_y + Math.cos(angle)*30 );
		ctx.lineTo(pos_x + 25*Math.sin(angle-Math.PI/12),pos_y + 25*Math.cos(angle-Math.PI/12));
		ctx.lineTo(pos_x + 25*Math.sin(angle+Math.PI/12),pos_y + 25*Math.cos(angle+Math.PI/12));
		ctx.lineTo(pos_x + Math.sin(angle)*30, pos_y + Math.cos(angle)*30 );
		ctx.fill();
		ctx.closePath();

		ctx.restore();
	

	}
	function visualizeAngles() {
		//console.log("Visualizing Direction Angle");

		ctx.save();
		ctx.translate(-field_x, -field_y);

		ctx.beginPath();
		ctx.lineWidth = "2";
		ctx.strokeStyle = "orange";
		ctx.moveTo(pos_x, pos_y);
		ctx.lineTo(pos_x + Math.sin(direction) * 30, pos_y + Math.cos(direction) * 30);
		ctx.stroke();
		ctx.closePath();

		if (target_waypoint != -1) {

			ctx.beginPath();
			ctx.lineWidth = "2";
			ctx.strokeStyle = "pink";
			ctx.moveTo(pos_x, pos_y);
			ctx.lineTo(pos_x + Math.sin(Math.atan2(waypoints[target_waypoint].x - pos_x, waypoints[target_waypoint].y - pos_y)) * 30, pos_y + Math.cos(Math.atan2(waypoints[target_waypoint].x - pos_x, waypoints[target_waypoint].y - pos_y)) * 30);
			ctx.stroke();
			ctx.closePath();
		}

		ctx.beginPath();
		ctx.lineWidth = "2";
		ctx.strokeStyle = "green";
		ctx.moveTo(pos_x, pos_y);
		ctx.lineTo(pos_x + Math.sin(direction+steer_angle) * 30, pos_y + Math.cos(direction+steer_angle) * 30);
		ctx.stroke();
		ctx.closePath();

		ctx.restore();

	}

	function mypoint(x,y){
		this.x = x;
		this.y = y;
	}

	function drawOnce() {
		
		ctx.clearRect(0, 0, fieldwidth, fieldheight);	
		drawField();
		drawSidewalk();
		drawStreets();
		drawBase();
		drawHouses();
 		mapData = ctx.getImageData(0,0,fieldwidth, fieldheight);
		
		
		
	}
	
	function adjustMap() {

		ctx.save();
		ctx.beginPath();
		ctx.putImageData(mapData,-field_x,-field_y);
		ctx.closePath();
		ctx.save();
		ctx.restore();
		
	}
	
	function draw(){
		requestAnimationFrame(draw);
		now = Date.now();
		dt = (now - time)*0.001;
		time = now;
		ctx.clearRect(0, 0, canvas.width, canvas.height);



		adjustMap();
		drawTaxi();
		drawScore();
		drawCargo();
		drawTaxis();
		drawTraffic();
		drawExperienceBar();
		drawSkills();
		drawProjectiles();
		//drawWaypoints();
		

		if(debug){
			visualizeAngles();
		}

		if(!pause) {
			act();
		}

		if((now-lastCargo) > 500){
			socket.emit("position",{id:myID,pos_x:pos_x,pos_y:pos_y,
				direction:direction,name:"MyName",lastUpdate:Date.now(),
				taxiWidth:taxiWidth,taxiHeight:taxiHeight,
				speed:speed,leftPressed:leftPressed,rightPressed:rightPressed,
				passengers:passengers});
		}

		logger();

	}


	function drawField() {
		ctx.save();
		ctx.beginPath();
		
		for(let x =3;x<Math.floor((fieldwidth-6)/10);x++) {
			for(let y =3;y<Math.floor((fieldheight-6)/10);y++) {
				let color =  Math.floor(Math.random()*30);
				
				ctx.fillStyle="rgb("+(30+color)+","+(23+color)+","+(25+color)+")";	
				ctx.fillRect(x,y,1,1);
			}	
			
		}
		ctx.closePath();
		ctx.save();
		ctx.beginPath();
		let backgroundPattern = ctx.getImageData(3,3,Math.floor((fieldwidth-6)/10),Math.floor((fieldheight-6)/10));
		
		for(let x =3;x<(fieldwidth-6);x+=Math.floor((fieldwidth-6)/10)-3) {
			for(let y=3;y<(fieldheight-6);y+=Math.floor((fieldheight-6)/10)-3) {
				ctx.putImageData(backgroundPattern,x,y);
			}	

		}
		
		ctx.closePath();
		ctx.save();
		ctx.beginPath();
		ctx.lineWidth="6";
		ctx.strokeStyle="black";
		ctx.rect(3,3, fieldwidth-6, fieldheight-6);
		ctx.stroke();
		ctx.closePath();
		ctx.restore();
		
	}
	
	reset();


	function drawTaxi() {

		ctx.save();
		ctx.translate(pos_x, pos_y);
		ctx.translate(-field_x,-field_y);
		ctx.rotate(-direction);
		ctx.drawImage(taxiImage,-taxiWidth/2, -taxiHeight/2, taxiWidth, taxiHeight);
		ctx.restore();

		/*
		ctx.save();
		ctx.translate(-field_x,-field_y);
		ctx.translate(pos_x, pos_y);
		ctx.rotate(-direction);
		ctx.beginPath();
		ctx.fillStyle = "black";
		ctx.arc(taxiConfig.pilot_x, taxiConfig.pilot_y, 3, 0, 2 * Math.PI);
		ctx.fill();
		ctx.closePath();
		ctx.restore();
		*/

		for (var p = 0; p < passengers; p++) {
			ctx.save();
			ctx.translate(pos_x, pos_y);
			ctx.translate(-field_x,-field_y);
			ctx.rotate(-direction);
			ctx.beginPath();
			switch(passengersList[p].color){
				case 0:
					ctx.fillStyle = "red";
					break;
				case 1:
					ctx.fillStyle = "pink";
					break;
				case 2:
					ctx.fillStyle = "yellow";
					break;
				case 3:
					ctx.fillStyle = "green";
					break;
				case 4:
					ctx.fillStyle = "blue";
					break;
				default:
					ctx.fillStyle = "red";
					break;
			}
			
			ctx.arc(taxiConfig.passenger_offset_x[p], taxiConfig.passenger_offset_y[p], 3, 0, 2 * Math.PI);
			ctx.fill();
			ctx.closePath();
			ctx.restore();

			baseArrow(passengersList[p].color);
		}

		if (pos_y + min_viewdistance > field_y + canvas.height) {
			field_y = field_y + ((pos_y + min_viewdistance) - (field_y + canvas.height));
		}
		if (pos_y - min_viewdistance < field_y) {
			field_y = field_y - (-(pos_y - min_viewdistance) + (field_y ));
		}
		if (pos_x + min_viewdistance > field_x + canvas.width) {
			field_x = field_x + ((pos_x + min_viewdistance) - (field_x + canvas.width));
		}
		if (pos_x - min_viewdistance < field_x) {
			field_x = field_x - (-(pos_x - min_viewdistance) + (field_x ));
		}

	}

	function drawTaxis(){
		for (let t = 0; t < taxis.length; t++) {
			if(taxis[t].id != myID) {

				ctx.save();
				ctx.translate(-field_x,-field_y);
				ctx.translate(taxis[t].pos_x, taxis[t].pos_y);
				ctx.rotate(-taxis[t].direction);
				ctx.drawImage(taxiImage,-taxis[t].taxiWidth / 2, -taxis[t].taxiHeight / 2, taxis[t].taxiWidth, taxis[t].taxiHeight);
				ctx.restore();
				/*
				for (p = 0; p < taxis[t].passengers; p++){
					ctx.save();
					ctx.translate(-field_x,-field_y);
					ctx.translate(taxis[t].pos_x,taxis[t].pos_y);
					ctx.rotate(-taxis[t].direction);
					ctx.beginPath();
					ctx.fillStyle = "red";
					ctx.arc(passenger_offset_x[p],passenger_offset_y[p],3,0,2*Math.PI);
					ctx.fill();
					ctx.closePath();
					ctx.restore();
				}
				*/
			}
		}

	}

	function drawTraffic(){
		for (let t = 0; t < traffic.length; t++) {
			ctx.save();
			ctx.translate(-field_x,-field_y);
			ctx.translate(traffic[t].pos.x, traffic[t].pos.y);
			ctx.rotate(-traffic[t].direction);
			ctx.drawImage(taxiImage,-traffic[t].width / 2, -traffic[t].height / 2, traffic[t].width, traffic[t].height);
			ctx.restore();

			//console.log("traffic[" + t + "]: " + traffic[t].pos.x + "/" + traffic[t].pos.y)
			/*
				 for (p = 0; p < taxis[t].passengers; p++){
				 ctx.save();
				 ctx.translate(-field_x,-field_y);
				 ctx.translate(taxis[t].pos_x,taxis[t].pos_y);
				 ctx.rotate(-taxis[t].direction);
				 ctx.beginPath();
				 ctx.fillStyle = "red";
				 ctx.arc(passenger_offset_x[p],passenger_offset_y[p],3,0,2*Math.PI);
				 ctx.fill();
				 ctx.closePath();
				 ctx.restore();
				 }
				 */

		}
	}

	function determineCenterOfPolygon(polygon) {
		let x = 0;
		let y = 0;
		for(let dot in polygon) {
			x += polygon[dot].x;
			y += polygon[dot].y;
		}
		return {'x': Math.floor(x/polygon.length), 'y':Math.floor(y/polygon.length)};
		
	}
	
	/*
	* param polygon: Polygon to scale down
	* param reduction: pixel for which each site should be reduced
	*/
	function scalePolygonAroundCenter(polygon,scale) {
		
		let center = determineCenterOfPolygon(polygon);

		let new_polygon = [];
		
		for(let dot in polygon) {
			let x = polygon[dot].x;
			let y = polygon[dot].y;
			let x_vektor = x-center.x;
			let y_vektor = y-center.y;
			let distance = Math.floor(Math.sqrt(Math.pow((x_vektor),2)+Math.pow((y_vektor),2)));

			x_vektor = Math.floor(x_vektor*(distance+scale)/distance);
			y_vektor = Math.floor(y_vektor*(distance+scale)/distance);
			
			x_vektor += center.x;
			y_vektor += center.y;
			
			new_polygon[new_polygon.length] = {'x':x_vektor,'y':y_vektor};		
		}
		
		return new_polygon;
		
		
	}
	
	function drawHouses(){
		console.log("Ich mal dann mal");
		for(let i=0;i<houses.length;i++) {
			console.log("Auf auf");
			ctx.save();
			ctx.beginPath();
			let house = scalePolygonAroundCenter(houses[i],-4);
			
			
			
			
			ctx.moveTo(house[0].x,house.y);
			for(let dot in house){
				ctx.lineTo(house[dot].x,house[dot].y);
			}
			
			ctx.lineTo(house[0].x,house[0].y);
			let center_x = 0;
			let center_y = 0;
			for(let dot in house) {
				center_x += house[dot].x;
				center_y += house[dot].y;
			}
			center_x = center_x/house.length-25+Math.floor(Math.random()*50);
			center_y = center_y/house.length-25+Math.floor(Math.random()*50);
			
			let gradient = ctx.createRadialGradient(center_x,center_y,100,center_x,center_y,10);
			let randomFactor = Math.floor(Math.random()*50)
			let randomColor_full = "rgb("+(131+randomFactor)+","+(124+randomFactor)+","+(114+randomFactor)+")";
			let randomColor_brighter = "rgb("+(131+randomFactor+10)+","+(124+randomFactor+10)+","+(114+randomFactor+10)+")";
			gradient.addColorStop(0, randomColor_full);
			gradient.addColorStop(1, randomColor_brighter);
			ctx.fillStyle = gradient;
	
			ctx.fill();
			
			ctx.lineWidth="8";
			ctx.strokeStyle = "#33333";
			ctx.moveTo(house[0].x,house.y);
			for(let dot in house){
				ctx.lineTo(house[dot].x,house[dot].y);
			}
			ctx.lineTo(house[0].x,house[0].y);
			ctx.lineTo(house[1].x,house[1].y);
			ctx.shadowColor = '#666';
			ctx.shadowBlur = 5;
			ctx.shadowOffsetX = 0;
			ctx.shadowOffsetY = 0;
			ctx.stroke();
			
			ctx.lineWidth="6";
			ctx.strokeStyle = "#c9c0b1";
			ctx.moveTo(house[0].x,house.y);
			for(let dot in house){
				ctx.lineTo(house[dot].x,house[dot].y);
			}
			ctx.lineTo(house[0].x,house[0].y);
			ctx.lineTo(house[1].x,house[1].y);
			ctx.stroke();
			ctx.closePath();
			
			ctx.restore();
		}
	}
	

	let maxChunksX;
	let maxChunksY;
	function drawSidewalk() {

		maxChunksX = Math.floor((fieldwidth-2*bordersize)/chunksize);
		maxChunksY = Math.floor((fieldheight-2*bordersize)/chunksize);

		console.log(maxChunksX);
	
		ctx.save();
		ctx.beginPath();
		for(let xId=0;xId<maxChunksX;xId++){
			for(let yId=0;yId<maxChunksY;yId++){
				let xCh = bordersize + xId*chunksize;
				let yCh =  bordersize+ yId*chunksize;
				ctx.lineWidth="10";
				ctx.strokeStyle = "#777777";
				ctx.moveTo(xCh+streetsize,yCh+streetsize);
				ctx.lineTo(xCh+chunksize-streetsize,yCh+streetsize);
				ctx.lineTo(xCh+chunksize-streetsize,yCh+chunksize-streetsize);
				ctx.lineTo(xCh+streetsize,yCh+chunksize-streetsize);
				ctx.lineTo(xCh+streetsize,yCh+streetsize);
				ctx.lineTo(xCh+chunksize-streetsize,yCh+streetsize);
				/*ctx.shadowColor = '#333';
				ctx.shadowBlur = 5;
				ctx.shadowOffsetX = 0;
				ctx.shadowOffsetY = 0;*/
				ctx.stroke();
				
				
			}
		}
		ctx.closePath();
		ctx.save();
		ctx.beginPath();
		for(let x_chunk =bordersize+streetsize+5;x_chunk<=bordersize+chunksize-streetsize-3;x_chunk+=5) {
			for(let y_chunk =bordersize+streetsize+5;y_chunk<=bordersize+chunksize-streetsize-3;y_chunk+=5) {
				let color = 100+Math.floor(Math.random()*40);
				ctx.fillStyle = "rgb("+color+","+color+","+color+")";
				ctx.fillRect(x_chunk,y_chunk,5,5);
				ctx.strokeStyle="#555";
				ctx.lineWidth="1";
				ctx.strokeRect(x_chunk,y_chunk,5,5);
				
			}
		}
		
		ctx.closePath();
		ctx.save();
		ctx.beginPath();
		let boardwalkPattern = ctx.getImageData(bordersize+streetsize+3,bordersize+streetsize+3,chunksize-streetsize*2-3,chunksize-streetsize*2-3);

		for(let xId=0;xId<maxChunksX;xId++){
			for(let yId=0;yId<maxChunksY;yId++){
				ctx.save();
				let x = bordersize+xId*chunksize+streetsize;
				let y = bordersize+yId*chunksize+streetsize
				ctx.putImageData(boardwalkPattern,x,y);
			}
	
		}
		ctx.closePath();
		ctx.save();

		ctx.beginPath();
		ctx.lineWidth="10";
		ctx.strokeStyle = "#777777";
		ctx.strokeRect(bordersize-streetsize,bordersize-streetsize,fieldwidth-bordersize,fieldheight-bordersize);
		ctx.closePath();
		
		ctx.restore();	
		
	}
	
	function drawStreets() {
		ctx.save();

		for(let xId=0;xId<maxChunksX;xId++){
			for(let yId=0;yId<maxChunksY;yId++){

				ctx.beginPath();
				let xCh = bordersize + xId*chunksize;
				let yCh =  bordersize+ yId*chunksize;
				
				ctx.setLineDash([25,35]);
				ctx.strokeStyle="#FFFFFF";
				
				ctx.moveTo(xCh+streetsize+12,yCh);
				ctx.lineTo(xCh+chunksize-streetsize,yCh);
				
				ctx.moveTo(xCh+chunksize,yCh+streetsize+12);
				ctx.lineTo(xCh+chunksize, yCh+chunksize-streetsize);
				
				ctx.moveTo(xCh+streetsize+12,yCh+chunksize);
				ctx.lineTo(xCh+chunksize-streetsize,yCh+chunksize);
				
				ctx.moveTo(xCh,yCh+streetsize+12);
				ctx.lineTo(xCh,yCh+chunksize-streetsize);
				
				ctx.stroke();

				ctx.closePath();
				ctx.restore();	
			}
		}

	}
	function drawCargo() {
		for(let f = 0; f < cargo.length; f++){
			ctx.save();
			ctx.beginPath();
			ctx.translate(-field_x,-field_y);
			ctx.arc(cargo[f].x, cargo[f].y, 3, 0, Math.PI*2);
			switch(cargo[f].color){
				case 0:
					ctx.fillStyle = "red";
					break;
				case 1:
					ctx.fillStyle = "pink";
					break;
				case 2:
					ctx.fillStyle = "yellow";
					break;
				case 3:
					ctx.fillStyle = "green";
					break;
				case 4:
					ctx.fillStyle = "blue";
					break;
				default:
					ctx.fillStyle = "red";
					break;
			}
			ctx.fill();
			ctx.closePath();
			ctx.restore();
		}
	}

	function drawScore(){
		ctx.font = "20px Arial";
		ctx.fillStyle = "grey";
		ctx.fillText("Highscore: " + highscore_name + ": " + highscore ,canvas.width-300,24);
		ctx.fillText("Score: " + points,canvas.width-300,49);
	}

	function drawBase(){

		ctx.save();

		for(let b = 0; b < bases.length; b++){
			switch(bases[b].color) {
				case 0:
					ctx.fillStyle = "red";
					break;
				case 1:
					ctx.fillStyle = "pink";
					break;
				case 2:
					ctx.fillStyle = "yellow";
					break;
				case 3:
					ctx.fillStyle = "green";
					break;
				case 4:
					ctx.fillStyle = "blue";
					break;
				default:
					ctx.fillStyle = "green";
					break;
			}
			ctx.beginPath();
			ctx.moveTo(bases[b].form[0].x, bases[b].form[0].y);
			for(let dot in bases[b].form){
				ctx.lineTo(bases[b].form[dot].x, bases[b].form[dot].y);
			}
			ctx.lineTo(bases[b].form[0].x, bases[b].form[0].y);
			ctx.closePath();
			ctx.fill();
		}


		ctx.restore();
	}

	function drawExperienceBar(){

		ctx.save();

		ctx.beginPath();
		ctx.lineWidth="2";
		ctx.strokeStyle="grey";
		ctx.rect(canvas.width/2-50, canvas.height-40,100,12);
		ctx.stroke();
		ctx.closePath();
		ctx.restore();

		ctx.beginPath();
		ctx.rect(canvas.width/2-48, canvas.height-38,98,8 );
		ctx.fillStyle = "white";
		ctx.fill();
		ctx.closePath();

		ctx.beginPath();
		ctx.rect(canvas.width/2-48, canvas.height-38, (experience/getExperience(level))*98,8 );
		ctx.fillStyle = "yellow";
		ctx.fill();
		ctx.closePath();

		ctx.font = "15px Arial";
		ctx.fillStyle = "grey";
		ctx.fillText("Level: " + level, canvas.width/2-30,canvas.height-46);

		//Health Bar
		ctx.beginPath();
		ctx.lineWidth="2";
		ctx.strokeStyle="grey";
		ctx.rect(canvas.width/2-200, canvas.height-40,100,12);
		ctx.stroke();
		ctx.closePath();
		ctx.restore();

		ctx.beginPath();
		ctx.rect(canvas.width/2-198, canvas.height-38,98,8 );
		ctx.fillStyle = "white";
		ctx.fill();
		ctx.closePath();

		ctx.beginPath();
		ctx.rect(canvas.width/2-198, canvas.height-38, (Math.max(health,0)/100)*98,8 );
		ctx.fillStyle = "yellow";
		ctx.fill();
		ctx.closePath();

		ctx.font = "15px Arial";
		ctx.fillStyle = "grey";
		ctx.fillText("Health: " + level, canvas.width/2-180,canvas.height-46);


	}

	function drawSkills(){

		var barHeight = 8;
		var frameHeight = 12;
		var frameWidth = 100;
		var barWidth = 96;
		var distance_font = 4;
		var offset_width = 150;
		var border = 2;
		var offsetHeight = 40;
		var heightdifference = 33;
		
		ctx.save();

		//Handling Level
		ctx.beginPath();
		ctx.lineWidth="2";
		ctx.strokeStyle="grey";
		ctx.rect(canvas.width-offset_width, canvas.height-offsetHeight,frameWidth,frameHeight);
		ctx.stroke();
		ctx.closePath();
		ctx.restore();

		ctx.beginPath();
		ctx.rect(canvas.width-offset_width+border, canvas.height-offsetHeight+border, barWidth,barHeight );
		ctx.fillStyle = "white";
		ctx.fill();
		ctx.closePath();

		ctx.beginPath();
		ctx.rect(canvas.width-offset_width+border, canvas.height-offsetHeight+border, ((handlingLevel)/handlingLevel_max)*barWidth,barHeight );
		ctx.fillStyle = "yellow";
		ctx.fill();
		ctx.closePath();

		ctx.font = "15px Arial";
		ctx.fillStyle = "grey";
		ctx.fillText("Handling: " + handlingLevel, canvas.width-offset_width,canvas.height-offsetHeight - distance_font);

		//BrakeLevel
		ctx.beginPath();
		ctx.lineWidth="2";
		ctx.strokeStyle="grey";
		ctx.rect(canvas.width-offset_width, canvas.height- offsetHeight - heightdifference, frameWidth,frameHeight);
		ctx.stroke();
		ctx.closePath();
		ctx.restore();

		ctx.beginPath();
		ctx.rect(canvas.width-offset_width+border, canvas.height-offsetHeight - heightdifference +border, barWidth,barHeight );
		ctx.fillStyle = "white";
		ctx.fill();
		ctx.closePath();

		ctx.beginPath();
		ctx.rect(canvas.width-offset_width+border, canvas.height-offsetHeight - heightdifference + border , ((brakelevel)/brakelevel_max)*barWidth,barHeight );
		ctx.fillStyle = "yellow";
		ctx.fill();
		ctx.closePath();

		ctx.font = "15px Arial";
		ctx.fillStyle = "grey";
		ctx.fillText("Brakes: " + brakelevel, canvas.width-offset_width,canvas.height-offsetHeight - heightdifference - distance_font);

		//Speed Level
		ctx.beginPath();
		ctx.lineWidth="2";
		ctx.strokeStyle="grey";
		ctx.rect(canvas.width-offset_width, canvas.height- offsetHeight - heightdifference*2, frameWidth,frameHeight);
		ctx.stroke();
		ctx.closePath();
		ctx.restore();

		ctx.beginPath();
		ctx.rect(canvas.width-offset_width+border, canvas.height-offsetHeight - heightdifference*2 +border, barWidth,barHeight );
		ctx.fillStyle = "white";
		ctx.fill();
		ctx.closePath();

		ctx.beginPath();
		ctx.rect(canvas.width-offset_width+border, canvas.height-offsetHeight - heightdifference*2 + border , ((speedlevel)/speedlevel_max)*barWidth,barHeight );
		ctx.fillStyle = "yellow";
		ctx.fill();
		ctx.closePath();

		ctx.font = "15px Arial";
		ctx.fillStyle = "grey";
		ctx.fillText("Speed: " + speedlevel, canvas.width-offset_width,canvas.height-offsetHeight - heightdifference*2 - distance_font);

		//Taxi Level
		ctx.beginPath();
		ctx.lineWidth="2";
		ctx.strokeStyle="grey";
		ctx.rect(canvas.width-offset_width, canvas.height- offsetHeight - heightdifference*3, frameWidth,frameHeight);
		ctx.stroke();
		ctx.closePath();
		ctx.restore();

		ctx.beginPath();
		ctx.rect(canvas.width-offset_width+border, canvas.height-offsetHeight - heightdifference*3 +border, barWidth,barHeight );
		ctx.fillStyle = "white";
		ctx.fill();
		ctx.closePath();

		ctx.beginPath();
		ctx.rect(canvas.width-offset_width+border, canvas.height-offsetHeight - heightdifference*3 + border , ((taxilevel)/taxilevel_max)*barWidth,barHeight );
		ctx.fillStyle = "yellow";
		ctx.fill();
		ctx.closePath();

		ctx.font = "15px Arial";
		ctx.fillStyle = "grey";
		ctx.fillText("Taxi: " + taxilevel, canvas.width-offset_width,canvas.height-offsetHeight - heightdifference*3 - distance_font);

		ctx.font = "20px Arial";
		ctx.fillStyle = "grey";
		ctx.fillText("Skillpoints: " + skillpoints, canvas.width-offset_width,canvas.height-offsetHeight - heightdifference*3 - distance_font - 22);

	}

	function drawProjectiles(){
		for (let p = 0; p < projectiles.length; p++){

			ctx.save();
			ctx.beginPath();
			ctx.translate(-field_x,-field_y);
			ctx.arc(projectiles[p].x, projectiles[p].y, 5, 0, Math.PI*2);
			ctx.fillStyle = "red";
			ctx.fill();
			ctx.closePath();
			ctx.restore();

		}
	}

	function actProjectiles(){
		for (let p = 0; p < projectiles.length; p++){

			projectiles[p].x = projectiles[p].x + (Math.sin(projectiles[p].direction) * projectiles[p].speed * dt);
			projectiles[p].y = projectiles[p].y + (Math.cos(projectiles[p].direction) * projectiles[p].speed * dt);
			projectiles[p].distance = projectiles[p].distance  -  (Math.sqrt(Math.pow(Math.sin(projectiles[p].direction) * projectiles[p].speed * dt,2)
							+ Math.pow(Math.cos(projectiles[p].direction) * projectiles[p].speed * dt ,2)));

			if( projectiles[p].distance < 0){
				projectiles.splice(p,1);
			}

		}
	}

	function shootProjectile(){

		let p = { 	x: pos_x + Math.sin(direction) * (taxiHeight+10),
				y: pos_y + Math.cos(direction) * (taxiWidth+10),
				speed: speed + 300,
				direction: direction,
				shooter: myID,
			    distance: 900
		};
		socket.emit("projectile",p);

	}

	function act(){

		actTaxi();
		actTaxis();
		checkCargoHit();
		deliverCargo();
		actProjectiles();
		collisionDetection();

		if(debug) {
			autoPilot();
		}
	}


	function actTaxi(){

		if (((pos_x + taxiWidth / 2) > fieldwidth) || ((pos_x - taxiWidth / 2) < 0) || ((pos_y + taxiHeight / 2) > fieldheight) || ((pos_y - taxiHeight / 2) < 0) || (health <= 0)) {
			lost();
		}

		if(health < health_max){
			health = Math.min(health + dt*health_regen,health_max);
		}

		if (now - spawnTime > 1000) {

			old ={x: pos_x, y: pos_y};

			if ( forwardPressed && speed < max_speed){
				speed = speed + acceleration*dt;
			}
			if(breaking && speed > - (max_speed/3) ){
				speed = speed - decelaration*dt;
			}
			if(!breaking && !forwardPressed && (Math.abs(speed) > 0) ){
				if(speed > 0){
					speed = Math.max(0,speed - dt*friction);
				}
				else{
					speed = Math.min(0,speed + dt*friction);
				}

			}
			if(!debug) {
				if (leftPressed) {
					steer_angle = Math.min(steer_angle + turningSpeed * dt, max_turning_angle / (Math.max(100, Math.abs(speed)) / 100));
				}
				else {
					if (rightPressed) {
						steer_angle = Math.max(steer_angle - turningSpeed * dt, -(max_turning_angle / (Math.max(100, Math.abs(speed)) / 100)));
					}
					else {

						if (steer_angle > 0) {
							steer_angle = steer_angle - 1.5 * dt;
							if (steer_angle < 0) {
								steer_angle = 0;
							}
						}
						if (steer_angle < 0) {
							steer_angle = steer_angle + 1.5 * dt;
							if (steer_angle > 0) {
								steer_angle = 0;
							}
						}

						//steer_angle = 0;

					}
				}
			}
			/*
			ctx.save();
			ctx.translate(-field_x,-field_y);

			ctx.beginPath();
			ctx.lineWidth="5";
			ctx.strokeStyle = "pink";
			ctx.moveTo(pos_x,pos_y);
			ctx.lineTo(pos_x + Math.sin(direction+steer_angle)*40, pos_y + Math.cos(direction+steer_angle)*40);
			ctx.stroke();
			ctx.closePath();

			ctx.restore();
			*/
			//console.log("wheels: " + frontWheel.x + "/" + frontWheel.y + "  " + backWheel.x + "/" + backWheel.y);
			/*
			var frontWheelL = {x: pos_x + (taxiHeight/2) * Math.sin(direction) + (taxiWidth/2) * Math.cos(direction),
							y: pos_y + (taxiHeight/2) * Math.cos(direction) + (taxiWidth/2) * Math.sin(direction)};
			var frontWheelR = {x: pos_x + (taxiHeight/2) * Math.sin(direction) - (taxiWidth/2) * Math.cos(direction),
				y: pos_y + (taxiHeight/2) * Math.cos(direction) - (taxiWidth/2) * Math.sin(direction)};
			var backWheelL = {x: pos_x - (taxiHeight/2) * Math.sin(direction) + (taxiWidth/2) * Math.cos(direction),
				y: pos_y - (taxiHeight/2) * Math.cos(direction) + (taxiWidth/2) * Math.sin(direction)};
			var backWheelR = {x: pos_x - (taxiHeight/2) * Math.sin(direction) - (taxiWidth/2) * Math.cos(direction),
				y: pos_y - (taxiHeight/2) * Math.cos(direction) - (taxiWidth/2) * Math.sin(direction)};


			//console.log("wheels: " + frontWheelL.x + "/" + frontWheelL.y + "  " + backWheelL.x + "/" + backWheelL.y);


			frontWheelL.x = frontWheelL.x + speed * dt * Math.sin(direction+steer_angle);
			frontWheelL.y = frontWheelL.y + speed * dt * Math.cos(direction+steer_angle);
			backWheelL.x =  backWheelL.x + speed * dt * Math.sin(direction);
			backWheelL.y = backWheelL.y + speed * dt * Math.cos(direction);
			frontWheelR.x = frontWheelR.x + speed * dt * Math.sin(direction+steer_angle);
			frontWheelR.y = frontWheelR.y + speed * dt * Math.cos(direction+steer_angle);
			backWheelR.x =  backWheelR.x + speed * dt * Math.sin(direction);
			backWheelR.y = backWheelR.y + speed * dt * Math.cos(direction);

			var frontpos = {x: frontWheelL.x - (frontWheelL.x - frontWheelR.x)/2,
							y: frontWheelL.y - (frontWheelL.y - frontWheelR.y)/2};
			var backpos = {x: backWheelL.x - (backWheelL.x - backWheelR.x)/2,
				y: backWheelL.y - (backWheelL.y - backWheelR.y)/2};

			//console.log("wheels: " + frontpos.x + "/" + frontpos.y + "  " + backpos.x + "/" + backpos.y);
			
			pos_x = (frontpos.x + backpos.x)/2;
			pos_y = (frontpos.y + backpos.y)/2;

			direction = Math.atan2((frontpos.x-backpos.x),(frontpos.y-backpos.y));
			*/
			var frontWheel = {x: pos_x + (taxiHeight*(2/5)) * Math.sin(direction),
				y: pos_y + (taxiHeight*(2/5)) * Math.cos(direction)};
			var backWheel = {x: pos_x - (taxiHeight*(2/5)) * Math.sin(direction),
				y: pos_y - (taxiHeight*(2/5)) * Math.cos(direction)};
			//console.log("wheels: " + frontWheel.x + "/" + frontWheel.y + "  " + backWheel.x + "/" + backWheel.y);
			
			let driftingFriction = 0.2;
			if(drifting) {
				let driftangle = 0;
				if (leftPressed){
					driftangle = -Math.PI/2;
					
				}else if (rightPressed) {
					driftangle = +Math.PI/2;
				}
				let driftForce_x=0;
				let driftForce_y=0;
				if(driftangle != 0) {
					driftForce_x = speed*driftingFriction * dt * Math.sin(direction+steer_angle);
					driftForce_y = speed*driftingFriction * dt * Math.cos(direction+steer_angle+driftangle);
				}
				backWheel.x =  backWheel.x + speed * dt * Math.sin(direction) + driftForce_x;
				backWheel.y = backWheel.y + speed* dt * Math.cos(direction) + driftForce_y;
				frontWheel.x = frontWheel.x + speed* dt * Math.sin(direction+steer_angle);
				frontWheel.y = frontWheel.y + speed * dt * Math.cos(direction+steer_angle);
			} else {
				frontWheel.x = frontWheel.x + speed * dt * Math.sin(direction+steer_angle);
				frontWheel.y = frontWheel.y + speed * dt * Math.cos(direction+steer_angle);
				backWheel.x =  backWheel.x + speed * dt * Math.sin(direction);
				backWheel.y = backWheel.y + speed * dt * Math.cos(direction);
			}
			pos_x = (frontWheel.x + backWheel.x)/2;
			pos_y = (frontWheel.y + backWheel.y)/2;
			direction = Math.atan2((frontWheel.x-backWheel.x),(frontWheel.y-backWheel.y));

		}
	}

	function actTaxis(){
		/*
	}
		for (var t = 0; t < taxis.length; t++) {
			if(taxis[t].id != myID) {
				if (taxis[t].leftPressed){
					taxis[t].direction = (((taxis[t].direction+(turningSpeed*dt))+Math.PI)%(2*Math.PI))-Math.PI;
				}
				if (taxis[t].rightPressed){
					if( (taxis[t].direction-(0.5*dt)) < (-Math.PI) ){
						taxis[t].direction = (taxis[t].direction-(turningSpeed*dt))+2*Math.PI;
					}
					else{
						taxis[t].direction = (((taxis[t].direction-(turningSpeed*dt))+Math.PI)%(2*Math.PI))-Math.PI;
					}
				}

				taxis[t].pos_x = taxis[t].pos_x + Math.sin(taxis[t].direction)*dt*taxis[t].speed;
				taxis[t].pos_y = taxis[t].pos_y + Math.cos(taxis[t].direction)*dt*taxis[t].speed;
			}
		}
		*/
	}

	function reset(){


		var valid_pos = false;
		while(!valid_pos){

			valid_pos = true;

			pos_x = Math.floor((Math.random() * (canvas.width-80)) + 40);
			pos_y = Math.floor((Math.random() * (canvas.height-80)) + 40);

			var c1 = rotatePoint([pos_x,pos_y], [pos_x+taxiWidth/2, pos_y+taxiHeight/2],direction);
			var c2 = rotatePoint([pos_x,pos_y], [pos_x+taxiWidth/2, pos_y-taxiHeight/2],direction);
			var c3 = rotatePoint([pos_x,pos_y], [pos_x-taxiWidth/2, pos_y+taxiHeight/2],direction);
			var c4 = rotatePoint([pos_x,pos_y], [pos_x-taxiWidth/2, pos_y-taxiHeight/2],direction);
			var mycorners = [
				{ 	x: c1[0],
					y: c1[1]
				},
				{ 	x: c2[0],
					y: c2[1]
				},
				{ 	x: c3[0],
					y: c3[1]
				},
				{ 	x: c4[0],
					y: c4[1]
				}
			];

			for(var h=0; h < houses.length; h++){

				var collision = doPolygonsIntersect(mycorners,houses[h]);
				if(collision){
					valid_pos = false;
				}

			}

		}

		field_x = 0;
		field_y = 0;

		passengers = 0;
        passengersList = [];

		direction = 0; // -PI to +Pi
		speed = 0;
		max_speed = 180;

		taxilevel = 0;
		max_passengers = getTaxiConfig(taxilevel).max_passengers;
		taxiWidth = getTaxiConfig(taxilevel).taxiWidth;
		taxiHeight = getTaxiConfig(taxilevel).taxiHeight;
		taxisize = 0

		handlingLevel = 0;
		turningSpeed = getHandling(handlingLevel);
		points = 0;
		spawnTime = Date.now();

		speedlevel = 0;
		max_speed = getMaxSpeed(speedlevel);

		brakelevel = 0;
		decelaration = getBreakingForce(brakelevel);

		level = 0;
		experience = 0;
		skillpoints = 0;

		taxiConfig = getTaxiConfig(taxisize);

		steer_angle = 0;

		forwardPressed = false;
		leftPressed = false;
		rightPressed = false;
		breaking = false;

		health = 100;

	}

	function lost(){
		speed = 0;
		//acceleration = 0;
		reset();
	}

	function checkCargoHit(){
		for (var c = 0; c<cargo.length; c++){
			if (cargo[c].x < pos_x+taxiWidth/2 && cargo[c].x > pos_x - taxiWidth/2){
				if (cargo[c].y < pos_y+taxiHeight/2 && cargo[c].y > pos_y - taxiHeight/2){
					if(addCargo(c)){
						cargo.splice(c,1);
						socket.emit("cargo",c);
					}
				}
			}
		}
	}

	function addCargo(c){
		if( passengers < max_passengers){
			passengers = passengers + 1;
			passengersList[passengersList.length] = cargo[c];
			return true;
		}
		return false;
	}

	function deliverCargo(){


		var c1 = rotatePoint([pos_x,pos_y], [pos_x+((taxiWidth/2) -5), pos_y+((taxiHeight/2) - 5)],direction);
		var c2 = rotatePoint([pos_x,pos_y], [pos_x+((taxiWidth/2) -5), pos_y-((taxiHeight/2) - 5)],direction);
		var c3 = rotatePoint([pos_x,pos_y], [pos_x-((taxiWidth/2) -5), pos_y+((taxiHeight/2) - 5)],direction);
		var c4 = rotatePoint([pos_x,pos_y], [pos_x-((taxiWidth/2) -5), pos_y-((taxiHeight/2) - 5)],direction);
		var mycorners = [
			{ 	x: c1[0],
				y: c1[1]
			},
			{ 	x: c2[0],
				y: c2[1]
			},
			{ 	x: c3[0],
				y: c3[1]
			},
			{ 	x: c4[0],
				y: c4[1]
			}
		];

		for(let b=0; b < bases.length; b++){

			var collision = doPolygonsIntersect(mycorners,bases[b].form);
			if(collision){
				for(let p = 0; p < passengersList.length; p++){

					if(passengersList[p].color == bases[b].color){
						points++;
						experience++;
						while( experience >= getExperience(level)){
							experience -= getExperience(level);
							level++;
							skillpoints++;
						}
						passengers--;
						passengersList.splice(p,1);
						p--;
					}
				}
			}
		}
	}

	function getExperience(level){
		switch(level){
			case 0:
				return 1;
			case 1:
				return 2;
			case 2:
				return 3;
		}
		return 5;
	}

	function getHandling(handlingLevel){
		switch(handlingLevel){
			case 0:
				return 1.5;
			case 1:
				return 1.7;
			case 2:
				return 1.9;
			case 3:
				return 2.1;
			case 4:
				return 2.3;
			case 5:
				return 2.5;
		}
		return 3;
	}

	function getTaxiConfig(taxilevel){
		var configuration = {	passenger_offset_x:[],
			passenger_offset_y:[],
			pilot_x:0, pilot_y:0,
			max_passengers:1, taxiWidth:15,
			taxiHeight:30
		};
		switch(taxilevel){
			case 0:
				configuration.passenger_offset_x = [0];
				configuration.passenger_offset_y = [-4];
				configuration.pilot_x = 0;
				configuration.pilot_y = 4;
				break;
			case 1:
				configuration.passenger_offset_x = [-3,3];
				configuration.passenger_offset_y = [-4,-4];
				configuration.pilot_x = 0;
				configuration.pilot_y = 4;
				configuration.max_passengers = 2;
				configuration.taxiWidth = 20;
				configuration.taxiHeight = 30;
				break;
			case 2:
				configuration.passenger_offset_x = [-3,3,-3,3];
				configuration.passenger_offset_y = [0,0,-8,-8];
				configuration.pilot_x = 0;
				configuration.pilot_y = 8;
				configuration.max_passengers = 4;
				configuration.taxiWidth = 20;
				configuration.taxiHeight = 35;
				break;
			case 3:
				configuration.passenger_offset_x = [-3,3,-3,3,-3,3];
				configuration.passenger_offset_y = [3,3,-5,-5,-13,-13];
				configuration.pilot_x = 0;
				configuration.pilot_y = 13;
				configuration.max_passengers = 6;
				configuration.taxiWidth = 22;
				configuration.taxiHeight = 40;
				break;
			case 4:
				configuration.passenger_offset_x = [0,6,-6,0,6,-6,0,6,-6];
				configuration.passenger_offset_y = [3,3,3,-5,-5,-5,-13,-13,-13];
				configuration.pilot_x = 0;
				configuration.pilot_y = 13;
				configuration.max_passengers = 9;
				configuration.taxiWidth = 30;
				configuration.taxiHeight = 40;
				break;
			case 5:
				configuration.passenger_offset_x = [0,6,-6,0,6,-6,0,6,-6,0,6,-6];
				configuration.passenger_offset_y = [8,8,8,0,0,0,-8,-8,-8,-16,-16,-16];
				configuration.pilot_x = 0;
				configuration.pilot_y = 18;
				configuration.max_passengers = 12;
				configuration.taxiWidth = 30;
				configuration.taxiHeight = 50;
				break;
			case 6:
				configuration.passenger_offset_x = [0,6,-6,0,6,-6,0,6,-6,0,6,-6,0,6,-6];
				configuration.passenger_offset_y = [13,13,13,5,5,5,-3,-3,-3,-11,-11,-11,-19,-19,-19];
				configuration.pilot_x = 0;
				configuration.pilot_y = 23;
				configuration.max_passengers = 15;
				configuration.taxiWidth = 33;
				configuration.taxiHeight = 60;
				break;
			case 7:
			case 8:
			case 9:
			case 10:
			case 11:
		}
		return configuration;
	}

	function getMaxSpeed(speedlevel){
		switch(speedlevel){
			case 0:
				return 180;
			case 1:
				return 220;
			case 2:
				return 250;
			case 3:
				return 300;
			case 4:
				return 400;
			case 5:
				return 500;
			default:
				return 500;
		}
	}

	function getBreakingForce(brakelevel){
		switch(brakelevel){
			case 0:
				return 140;
			case 1:
				return 180;
			case 2:
				return 220;
			case 3:
				return 300;
			case 4:
				return 380;
			case 5:
				return 500;
			default:
				return 700;
		}
	}

	function keyDownHandler(e) {
		if(e.keyCode == 39) {
			rightPressed = true;
		}
		else if(e.keyCode == 37) {
			leftPressed = true;
		}
		else if(e.keyCode == 38) {
			forwardPressed = true;
		}
		else if(e.keyCode == 68) {
			debug = !debug;
		}
		else if(e.keyCode == 70) {
			autoPilotturningSpeed++;
		}
		else if(e.keyCode == 52) {
			if(skillpoints > 0) {
				if (handlingLevel < handlingLevel_max) {
					handlingLevel++;
					turningSpeed = getHandling(handlingLevel);
					skillpoints--;
				}
			}
		}
		else if(e.keyCode == 51) {
			if(skillpoints > 0) {
				if (brakelevel < brakelevel_max) {
					brakelevel++;

					decelaration = getBreakingForce(brakelevel);
					skillpoints--;
				}
			}
		}
		else if(e.keyCode == 49) {
			if(skillpoints > 0) {
				if (taxilevel < taxilevel_max) {
					taxilevel++;

					taxiConfig = getTaxiConfig(taxilevel);
					max_passengers = getTaxiConfig(taxilevel).max_passengers;
					taxiWidth = getTaxiConfig(taxilevel).taxiWidth;
					taxiHeight = getTaxiConfig(taxilevel).taxiHeight;

					skillpoints--;
				}
			}
		}else if(e.keyCode == 50) {
			if(skillpoints > 0) {
				if (speedlevel < speedlevel_max) {
					speedlevel++;
					max_speed = getMaxSpeed(speedlevel);
					skillpoints--;
				}
			}
		}
		else if(e.keyCode == 40) {
			breaking = true;
		}
		else if(e.keyCode == 17) {

			pause = !pause;
			/*
			if (now - lastShot > 1000){
				shootProjectile();
				lastShot = now;
			}
			*/
		}
		else if(e.keyCode == 32) {
			drifting = true;
		}
		//console.log("key: " + e.keyCode);
	}

	function keyUpHandler(e) {
		if(e.keyCode == 39) {
			rightPressed = false;
		}
		else if(e.keyCode == 37) {
			leftPressed = false;
		}
		else if(e.keyCode == 40) {
			breaking = false;
		}
		else if(e.keyCode == 38) {
			forwardPressed = false;
		}
		else if(e.keyCode == 32) {
			drifting = false;

		}
	}

	function logger(){

		if(now - lastLogged > logInterval ){
			lastLogged = now;
		}

	}

	function collissionHandlingHouses(id){

		//find collision side
		var smallest_distance = 10000;
		var smallest_distance_1 = -1;
		var smallest_distance_2 = -1;
		for(let i = 0; i < houses[id].length; i++ ) {


			var r1 = { x: houses[id][i].x, y: houses[id][i].y};
			var a = {
				x: (houses[id][i].x - houses[id][(i+1)%(houses[id].length)].x),
				y: (houses[id][i].y - houses[id][(i+1)%(houses[id].length)].y)
			};
			var rq = { x: pos_x+Math.sin(direction)*taxiHeight/2, y:pos_y+Math.cos(direction)*taxiHeight/2};

			var b = { x: rq.x - r1.x, y: rq.y - r1.y};
			var cross = a.x*b.y  - b.x * a.y;

			//var top = Math.sqrt( Math.pow(cross,2) + Math.pow(cross.y,2) );
			var top = Math.abs(cross);
			var down = Math.sqrt( Math.pow(a.x,2) + Math.pow(a.y,2));

			//console.log("top: " +top);
			//console.log("down: " +down);

			var distance = top/down;
			if(smallest_distance > distance){
				smallest_distance = distance;
				if(i == (houses[id].length-1) ){
					smallest_distance_1 = i;
					smallest_distance_2 = (i+1)%(houses[id].length);
				}
				else {
					smallest_distance_2 = i;
					smallest_distance_1 = (i + 1) % (houses[id].length);
				}
			}

		}


		//find collision angle
		var atan1 = (Math.atan2( houses[id][smallest_distance_1].x - houses[id][smallest_distance_2].x, houses[id][smallest_distance_1].y - houses[id][smallest_distance_2].y ) );
		var atan2 = (Math.atan2( houses[id][smallest_distance_2].x - houses[id][smallest_distance_1].x, houses[id][smallest_distance_2].y - houses[id][smallest_distance_1].y ) );
		var between1 = Math.min( 2*Math.PI - Math.abs(direction-atan1), Math.abs(direction-atan1) );
		var between2 = Math.min( 2*Math.PI - Math.abs(direction-atan2), Math.abs(direction-atan2) );
		if( between1 <  between2){
			pos_x = old.x;
			pos_y = old.y;

			health = health - Math.abs((speed/10))* Math.abs(Math.sin(between1));
			//console.log("health: " + health + "  speed: " + speed + "sin: " + Math.abs(Math.sin(between1)));
			speed = speed * Math.cos(between1)

			pos_x = pos_x + Math.sin(atan1)*speed*dt;
			pos_y = pos_y + Math.cos(atan1)*speed*dt;


		}else{
			pos_x = old.x;
			pos_y = old.y;

			health = health - Math.abs((speed/10))* Math.abs(Math.sin(between2));
			//console.log("health: " + health + "  speed: " + speed + "sin: " + Math.abs(Math.sin(between2)));
			speed = speed * Math.cos(between2)

			pos_x = pos_x + Math.sin(atan2)*speed*dt;
			pos_y = pos_y + Math.cos(atan2)*speed*dt;
		}
		//actTaxi();
		//console.log("angle: " + direction);

		//speed = 20;



	}

	function collisionDetection(){
		/*
		var c1 = rotatePoint([pos_x,pos_y], [pos_x+((taxiWidth/2) -0), pos_y+((taxiHeight/2) - 0)],direction);
		var c2 = rotatePoint([pos_x,pos_y], [pos_x+((taxiWidth/2) -0), pos_y-((taxiHeight/2) - 0)],direction);
		var c3 = rotatePoint([pos_x,pos_y], [pos_x-((taxiWidth/2) -0), pos_y+((taxiHeight/2) - 0)],direction);
		var c4 = rotatePoint([pos_x,pos_y], [pos_x-((taxiWidth/2) -0), pos_y-((taxiHeight/2) - 0)],direction);
		*/
		var c1 = [ pos_x + (taxiHeight/2) * Math.sin(direction) + (taxiWidth/2) * Math.cos(direction),
			 pos_y + (taxiHeight/2) * Math.cos(direction) + (taxiWidth/2) * Math.sin(direction)];
		var c2 = [ pos_x + (taxiHeight/2) * Math.sin(direction) - (taxiWidth/2) * Math.cos(direction),
			 pos_y + (taxiHeight/2) * Math.cos(direction) - (taxiWidth/2) * Math.sin(direction)];
		var c3 = [ pos_x - (taxiHeight/2) * Math.sin(direction) + (taxiWidth/2) * Math.cos(direction),
			 pos_y - (taxiHeight/2) * Math.cos(direction) + (taxiWidth/2) * Math.sin(direction)];
		var c4 = [ pos_x - (taxiHeight/2) * Math.sin(direction) - (taxiWidth/2) * Math.cos(direction),
			 pos_y - (taxiHeight/2) * Math.cos(direction) - (taxiWidth/2) * Math.sin(direction)];
		var mycorners = [
			{ 	x: c1[0],
				y: c1[1]
			},
			{ 	x: c2[0],
				y: c2[1]
			},
			{ 	x: c3[0],
				y: c3[1]
			},
			{ 	x: c4[0],
				y: c4[1]
			}
		];

		for(let t=0; t < taxis.length; t++){

			if(taxis[t].id != myID){				

				var d1 = rotatePoint([taxis[t].pos_x,taxis[t].pos_y], [taxis[t].pos_x+taxis[t].taxiWidth/2, taxis[t].pos_y+taxis[t].taxiHeight/2],taxis[t].direction);
				var d2 = rotatePoint([taxis[t].pos_x,taxis[t].pos_y], [taxis[t].pos_x+taxis[t].taxiWidth/2, taxis[t].pos_y-taxis[t].taxiHeight/2],taxis[t].direction);
				var d3 = rotatePoint([taxis[t].pos_x,taxis[t].pos_y], [taxis[t].pos_x-taxis[t].taxiWidth/2, taxis[t].pos_y+taxis[t].taxiHeight/2],taxis[t].direction);
				var d4 = rotatePoint([taxis[t].pos_x,taxis[t].pos_y], [taxis[t].pos_x-taxis[t].taxiWidth/2, taxis[t].pos_y-taxis[t].taxiHeight/2],taxis[t].direction);
				var othercorners = [
					{ 	x: d1[0],
						y: d1[1]
					},
					{ 	x: d2[0],
						y: d2[1]
					},
					{ 	x: d3[0],
						y: d3[1]
					},
					{ 	x: d4[0],
						y: d4[1]
					}
				];

				var collision = doPolygonsIntersect(mycorners,othercorners);
				if(collision){
					lost();
				}

			}

		}

		for(let h=0; h < houses.length; h++){

			var collision = doPolygonsIntersect(mycorners,houses[h]);
			if(collision){
				collissionHandlingHouses(h);
				//lost();
			}
		}

		for(let p = 0; p < projectiles.length; p++){
			if( Math.sqrt(Math.pow(projectiles[p].x - pos_x,2) + Math.pow(projectiles[p].y - pos_y,2)) < (2+taxiWidth/2) ) {
				if (projectiles[p].shooter != myID) {
					lost();
				}
			}
		}

	}

	function rotatePoint(pivot, point, angle) {
		// Rotate clockwise, angle in radians
		var x = Math.round((Math.cos(angle) * (point[0] - pivot[0])) -
						(Math.sin(angle) * (point[1] - pivot[1])) +
						pivot[0]),
				y = Math.round((Math.sin(angle) * (point[0] - pivot[0])) +
						(Math.cos(angle) * (point[1] - pivot[1])) +
						pivot[1]);
		return [x, y];
	}

	/**
	 * Helper function to determine whether there is an intersection between the two polygons described
	 * by the lists of vertices. Uses the Separating Axis Theorem
	 *
	 * @param a an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon
	 * @param b an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon
	 * @return true if there is any intersection between the 2 polygons, false otherwise
	 */
	function doPolygonsIntersect (a, b) {
		var polygons = [a, b];
		var minA, maxA, projected, i, i1, j, minB, maxB;

		for (i = 0; i < polygons.length; i++) {

			// for each polygon, look at each edge of the polygon, and determine if it separates
			// the two shapes
			var polygon = polygons[i];
			for (i1 = 0; i1 < polygon.length; i1++) {

				// grab 2 vertices to create an edge
				var i2 = (i1 + 1) % polygon.length;
				var p1 = polygon[i1];
				var p2 = polygon[i2];

				// find the line perpendicular to this edge
				var normal = { x: p2.y - p1.y, y: p1.x - p2.x };

				minA = maxA = undefined;
				// for each vertex in the first shape, project it onto the line perpendicular to the edge
				// and keep track of the min and max of these values
				for (j = 0; j < a.length; j++) {
					projected = normal.x * a[j].x + normal.y * a[j].y;
					if ((minA == undefined) || projected < minA) {
						minA = projected;
					}
					if ((maxA == undefined) || projected > maxA) {
						maxA = projected;
					}
				}

				// for each vertex in the second shape, project it onto the line perpendicular to the edge
				// and keep track of the min and max of these values
				minB = maxB = undefined;
				for (j = 0; j < b.length; j++) {
					projected = normal.x * b[j].x + normal.y * b[j].y;
					if ((minB == undefined) || projected < minB) {
						minB = projected;
					}
					if ((maxB == undefined) || projected > maxB) {
						maxB = projected;
					}
				}

				// if there is no overlap between the projects, the edge we are looking at separates the two
				// polygons, and we know there is no overlap
				if (maxA < minB || maxB < minA) {
					//CONSOLE("polygons don't intersect!");
					return false;
				}
			}
		}
		return true;
	}

	</script>	
	
  </body>
</html>
