<!doctype html>
<html>
  <head>
    <title>Socket.IO chat</title>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      body { font: 13px Helvetica, Arial;  overflow: hidden; }
      form { background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; }
      form input { border: 0; padding: 10px; width: 90%; margin-right: .5%; }
      form button { width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; }
      #messages { list-style-type: none; margin: 0; padding: 0; }
      #messages li { padding: 5px 10px; }
      #messages li:nth-child(odd) { background: #eee; }
    </style>
  </head>
  <body>
  
  
	<script src="/socket.io/socket.io.js"></script>
	
	<canvas id="myCanvas" width="1280" height="720"></canvas>

	<script>

	var canvas = document.getElementById("myCanvas");
	var ctx = canvas.getContext("2d");
	ctx.canvas.width  = window.innerWidth;
	ctx.canvas.height = window.innerHeight;

	var taxisize = 0;
	var taxiWidth = 15;
	var taxiHeight = 30;
	var passengers = 0;
	var max_passengers = 1;
	var passenger_offset_x = [0,6,-6,0,6,-6,0,6,-6,0,6,-6];
	var passenger_offset_y = [-4,-4,-4,-12,-12,-12,-20,-20,-20,-28,-28,-28];
	var taxiConfig = getTaxiConfig(taxisize);
	var direction = 0; // -PI to +Pi
	var speed = 0;
	var max_speed = 180;
	var acceleration = 30;
	var speed_gain = 10;
	var handlingLevel = 0;
	var handlingLevel_max = 5;
	var taxilevel = 0;
	var taxilevel_max = 6;
	var turningSpeed = getHandling(handlingLevel);
	var autoPilotturningSpeed = 8;
	var pos_x = Math.floor((Math.random() * canvas.width-100) + 50);
	var pos_y = Math.floor((Math.random() * canvas.height-100) + 50);
	var points = 0;
	var min_viewdistance = 500;
	var highscore = 0;
	var highscore_name = "NoOne";
	var name = "Player1";
	var myID = Math.floor((Math.random() * 1000)) + 1;
	var fieldwidth = 2000;
	var fieldheight = 1000;
	var field_x = 0;
	var field_y = 0;
	var connected = false;
	var taxis = [];
	var houses = [];
	var now = Date.now();
	var time = now;
	var spawnTime = now;
	var lastCargo = now;
	var lastLogged = now;
	var logInterval = 500;
	var dt = 0;
	var cargo = [];
	var base = { x:75, y:75, radius:75};
	var rightPressed = false;
	var leftPressed = false;
	var socket = io();
	var debug = false;
	var target = {x:-1,y:-1};
	var level = 0;
	var experience = 0;
	var skillpoints = 0;
	var brakelevel = 0;
	var brakelevel_max = 5;
	var decelaration = (getBrakeConfig(brakelevel)).deceleration;
	var breaking_power = 200;
	var breaking_power_max = (getBrakeConfig(brakelevel)).breaking_power_max;
	var breaking_reload = (getBrakeConfig(brakelevel)).breaking_reload;
	var breaking = false;
	var max_turning_speed = 8;

	ctx.font = "10px Arial";

	socket.on('data', function(servercargo){
		cargo = servercargo;
	});

	socket.on('taxis', function(servertaxis){
		taxis = servertaxis;
	});

  socket.on('houses', function(serverhouses){

	console.log("Getting houses")
     houses = serverhouses
  });

	socket.on('score', function(score){
		highscore = score.highscore;
		highscore_name = score.name;
	});

	document.addEventListener("keydown", keyDownHandler, false);
	document.addEventListener("keyup", keyUpHandler, false);

	function autoPilot(){

		var targetFound = false;
		var min_distance = -1;
		if((passengers == max_passengers) || (cargo.length == 0)){
			target = {x:base.x, y:base.y};
			autoPilotGoToTarget();
		}
		else{
			for(var c = 0; c < cargo.length; c++){
				if(targetFound == false && cargo[c].x > 30 && cargo[c].x < (fieldwidth-30) && cargo[c].y > 30 && cargo[c].y < (fieldheight-30) ){
					target = {x: cargo[c].x, y:cargo[c].y};
					min_distance = Math.sqrt(Math.pow(pos_x - cargo[c].x,2)+Math.pow(pos_y - cargo[c].y,2));
					targetFound = true;
				}
				else{
					if( (min_distance - Math.sqrt(Math.pow(pos_x - cargo[c].x,2)+Math.pow(pos_y - cargo[c].y,2))) > 0){
						target = {x: cargo[c].x, y:cargo[c].y};
						min_distance = Math.sqrt(Math.pow(pos_x - cargo[c].x,2)+Math.pow(pos_y - cargo[c].y,2));
					}
				}
			}

		}
		if(targetFound){
			autoPilotGoToTarget();
		}
		if(skillpoints > 0) {
			if (taxilevel < taxilevel_max) {
				taxilevel++;

				taxiConfig = getTaxiConfig(taxilevel);
				max_passengers = getTaxiConfig(taxilevel).max_passengers;
				taxiWidth = getTaxiConfig(taxilevel).taxiWidth;
				taxiHeight = getTaxiConfig(taxilevel).taxiHeight;

				skillpoints--;
			}
		}

	}

	function autoPilotGoToTarget() {

		var crossProduct = Math.sin(direction) * (pos_y - target.y) - ( Math.cos(direction) * (pos_x - target.x)  );
		//console.log("direction: " + direction + " target: " + target.x + "/" + target.y + " cross: " + crossProduct);
		if (Math.abs(crossProduct) > 1) {

			if (crossProduct > 0) {

				direction = (((direction + (2 * autoPilotturningSpeed * dt)) + Math.PI) % (2 * Math.PI)) - Math.PI;
				crossProduct = Math.sin(direction) * (pos_y - target.y) - ( Math.cos(direction) * (pos_x - target.x)  );
				if (crossProduct < 0) {
					direction = Math.atan2(target.x-pos_x,target.y-pos_y);
				}
			}
			else {
				if ((direction - (0.5 * dt)) < (-Math.PI)) {
					direction = (direction - (2 * autoPilotturningSpeed * dt)) + 2 * Math.PI;
				}
				else {
					direction = (((direction - (2 * autoPilotturningSpeed * dt)) + Math.PI) % (2 * Math.PI)) - Math.PI;
				}

				crossProduct = Math.sin(direction) * (pos_y - target.y) - ( Math.cos(direction) * (pos_x - target.x)  );
				if (crossProduct > 0) {
					direction = Math.atan2(target.x-pos_x,target.y-pos_y);
				}
			}
		}


	}

	function visualizeAngles(){
		//console.log("Visualizing Direction Angle");

		ctx.save();
		ctx.translate(-field_x,-field_y);

		ctx.beginPath();
		ctx.lineWidth="5";
		ctx.strokeStyle = "orange";
		ctx.moveTo(pos_x,pos_y);
		ctx.lineTo(pos_x + Math.sin(direction)*30, pos_y + Math.cos(direction)*30 );
		ctx.stroke();
		ctx.closePath();

		ctx.beginPath();
		ctx.lineWidth="5";
		ctx.strokeStyle = "pink";
		ctx.moveTo(pos_x,pos_y);
		ctx.lineTo(pos_x + Math.sin(Math.atan2(target.x - pos_x,target.y-pos_y))*30, pos_y + Math.cos(Math.atan2(target.x-pos_x, target.y -pos_y))*30 );
		ctx.stroke();
		ctx.closePath();

		ctx.restore();

	}

	function mypoint(x,y){
		this.x = x;
		this.y = y;
	}

	function draw(){
		requestAnimationFrame(draw);
		now = Date.now();
		dt = (now - time)*0.001;
		time = now;
		ctx.clearRect(0, 0, canvas.width, canvas.height);



		drawHouses();
		drawBase();
		drawTaxi();
		drawScore();
		drawCargo();
		drawTaxis();
		drawExperienceBar();
		drawSkills();

		ctx.save();
		ctx.translate(-field_x,-field_y);
		ctx.beginPath();
		ctx.lineWidth="6";
		ctx.strokeStyle="black";
		ctx.rect(3,3, fieldwidth-6, fieldheight-6);
		ctx.stroke();
		ctx.closePath();
		ctx.restore();

		if(debug){
			visualizeAngles();
		}

		this.act();

		if((now-lastCargo) > 500){
			socket.emit("position",{id:myID,pos_x:pos_x,pos_y:pos_y,
				direction:direction,name:"MyName",lastUpdate:Date.now(),
				taxiWidth:taxiWidth,taxiHeight:taxiHeight,
				speed:speed,leftPressed:leftPressed,rightPressed:rightPressed,
				passengers:passengers});
		}

		logger();

	}

	draw();

	function drawTaxi() {

		ctx.save();
		ctx.translate(pos_x, pos_y);
		ctx.translate(-field_x,-field_y);
		ctx.rotate(-direction);
		ctx.fillStyle = "blue";
		ctx.fillRect(-taxiWidth / 2, -taxiHeight / 2, taxiWidth, taxiHeight);
		ctx.restore();

		ctx.save();
		ctx.translate(-field_x,-field_y);
		ctx.translate(pos_x, pos_y);
		ctx.rotate(-direction);
		ctx.beginPath();
		ctx.fillStyle = "black";
		ctx.arc(taxiConfig.pilot_x, taxiConfig.pilot_y, 3, 0, 2 * Math.PI);
		ctx.fill();
		ctx.closePath();
		ctx.restore();

		for (var p = 0; p < passengers; p++) {
			ctx.save();
			ctx.translate(pos_x, pos_y);
			ctx.translate(-field_x,-field_y);
			ctx.rotate(-direction);
			ctx.beginPath();
			ctx.fillStyle = "red";
			ctx.arc(taxiConfig.passenger_offset_x[p], taxiConfig.passenger_offset_y[p], 3, 0, 2 * Math.PI);
			ctx.fill();
			ctx.closePath();
			ctx.restore();
		}


		if (pos_y + min_viewdistance > field_y + canvas.height) {
			field_y = field_y + ((pos_y + min_viewdistance) - (field_y + canvas.height));
			//field_y = field_y + Math.cos(direction)*speed;
		}
		if (pos_y - min_viewdistance < field_y) {
			field_y = field_y - (-(pos_y - min_viewdistance) + (field_y ));
		}
		//if (field_y < 0) {
		//	field_y = 0;
		//}
		if (field_y + canvas.height > fieldheight) {
			field_y = fieldheight - canvas.height
		}
		if (pos_x + min_viewdistance > field_x + canvas.width) {
			field_x = field_x + ((pos_x + min_viewdistance) - (field_x + canvas.width));
		}
		if (pos_x - min_viewdistance < field_x) {
			field_x = field_x - (-(pos_x - min_viewdistance) + (field_x ));
		}
		//if (field_x < 0) {
		//	field_x = 0;
		//}
		//if (field_x + canvas.width > fieldwidth) {
		//	field_x = fieldwidth - canvas.width
		//}

	}

	function drawTaxis(){
		for (var t = 0; t < taxis.length; t++) {
			if(taxis[t].id != myID) {
				ctx.save();
				ctx.translate(-field_x,-field_y);
				ctx.translate(taxis[t].pos_x, taxis[t].pos_y);
				ctx.rotate(-taxis[t].direction);
				ctx.fillStyle = "blue";
				ctx.fillRect(-taxis[t].taxiWidth / 2, -taxis[t].taxiHeight / 2, taxis[t].taxiWidth, taxis[t].taxiHeight);

				ctx.restore();

				ctx.save();
				ctx.translate(-field_x,-field_y);
				ctx.translate(taxis[t].pos_x, taxis[t].pos_y);
				ctx.rotate(-taxis[t].direction);
				ctx.beginPath();
				ctx.fillStyle = "black";
				ctx.arc(0, 4, 3, 0, 2 * Math.PI);
				ctx.fill();
				ctx.closePath();
				ctx.restore();

				for (var p = 0; p < taxis[t].passengers; p++){
					ctx.save();
					ctx.translate(-field_x,-field_y);
					ctx.translate(taxis[t].pos_x,taxis[t].pos_y);
					ctx.rotate(-taxis[t].direction);
					ctx.beginPath();
					ctx.fillStyle = "red";
					ctx.arc(passenger_offset_x[p],passenger_offset_y[p],3,0,2*Math.PI);
					ctx.fill();
					ctx.closePath();
					ctx.restore();
				}
			}
		}

	}
  
	function drawHouses(){
		for(var i=0;i<houses.length;i++) {
			ctx.save();
			ctx.translate(-field_x,-field_y);
			ctx.beginPath();
			ctx.moveTo(houses[i][0].x,houses[i].y);
			for(dot in houses[i]){
				ctx.lineTo(houses[i][dot].x,houses[i][dot].y);
			}
			ctx.lineTo(houses[i][0].x,houses[i].y);
			ctx.closePath();
			ctx.fillStyle = "black";
			ctx.fill();
			ctx.restore();
		}
	}

	function drawCargo() {
		for(f = 0; f < cargo.length; f++){
			ctx.save();
			ctx.beginPath();
			ctx.translate(-field_x,-field_y);
			ctx.arc(cargo[f].x, cargo[f].y, 3, 0, Math.PI*2);
			ctx.fillStyle = "red";
			ctx.fill();
			ctx.closePath();
			ctx.restore();
		}
	}

	function drawScore(){
		ctx.font = "20px Arial";
		ctx.fillStyle = "black";
		ctx.fillText("Highscore: " + highscore_name + ": " + highscore ,canvas.width-300,24);
		ctx.fillText("Score: " + points,canvas.width-300,49);
	}

	function drawBase(){
		ctx.save();
		ctx.translate(-field_x,-field_y);
		ctx.beginPath();
		ctx.rect(base.x-base.radius, base.y-base.radius, base.radius*2, base.radius*2);
		ctx.fillStyle = "green";
		ctx.fill();
		ctx.closePath();
		ctx.restore();
	}

	function drawExperienceBar(){

		ctx.save();
		//ctx.translate(-field_x,-field_y);

		ctx.beginPath();
		ctx.lineWidth="2";
		ctx.strokeStyle="black";
		ctx.rect(canvas.width/2-50, canvas.height-40,100,12);
		ctx.stroke();
		ctx.closePath();
		ctx.restore();

		ctx.beginPath();
		ctx.rect(canvas.width/2-48, canvas.height-38, (experience/getExperience(level))*98,8 );
		ctx.fillStyle = "yellow";
		ctx.fill();
		ctx.closePath();

		ctx.font = "15px Arial";
		ctx.fillStyle = "black";
		ctx.fillText("Level: " + level, canvas.width/2-30,canvas.height-46);


	}

	function drawSkills(){

		var barHeight = 8;
		var frameHeight = 12;
		var frameWidth = 100;
		var barWidth = 96;
		var distance_font = 4;
		var offset_width = 150;
		var border = 2;
		var offsetHeight = 40;
		var heightdifference = 33;
		
		ctx.save();
		//ctx.translate(-field_x,-field_y);

		ctx.beginPath();
		ctx.lineWidth="2";
		ctx.strokeStyle="black";
		ctx.rect(canvas.width-offset_width, canvas.height-offsetHeight,frameWidth,frameHeight);
		ctx.stroke();
		ctx.closePath();
		ctx.restore();

		ctx.beginPath();
		ctx.rect(canvas.width-offset_width+border, canvas.height-offsetHeight+border, ((handlingLevel)/handlingLevel_max)*barWidth,barHeight );
		ctx.fillStyle = "yellow";
		ctx.fill();
		ctx.closePath();

		ctx.font = "15px Arial";
		ctx.fillStyle = "black";
		ctx.fillText("Handling: " + handlingLevel, canvas.width-offset_width,canvas.height-offsetHeight - distance_font);

		ctx.beginPath();
		ctx.lineWidth="2";
		ctx.strokeStyle="black";
		ctx.rect(canvas.width-offset_width, canvas.height- offsetHeight - heightdifference, frameWidth,frameHeight);
		ctx.stroke();
		ctx.closePath();
		ctx.restore();

		ctx.beginPath();
		ctx.rect(canvas.width-offset_width+border, canvas.height-offsetHeight - heightdifference + border , ((brakelevel)/brakelevel_max)*barWidth,barHeight );
		ctx.fillStyle = "yellow";
		ctx.fill();
		ctx.closePath();

		ctx.font = "15px Arial";
		ctx.fillStyle = "black";
		ctx.fillText("Brakes: " + brakelevel, canvas.width-offset_width,canvas.height-offsetHeight - heightdifference - distance_font);

		ctx.beginPath();
		ctx.lineWidth="2";
		ctx.strokeStyle="black";
		ctx.rect(canvas.width-offset_width, canvas.height- offsetHeight - heightdifference*2, frameWidth,frameHeight);
		ctx.stroke();
		ctx.closePath();
		ctx.restore();

		ctx.beginPath();
		ctx.rect(canvas.width-offset_width+border, canvas.height-offsetHeight - heightdifference*2 + border , ((taxilevel)/taxilevel_max)*barWidth,barHeight );
		ctx.fillStyle = "yellow";
		ctx.fill();
		ctx.closePath();

		ctx.font = "15px Arial";
		ctx.fillStyle = "black";
		ctx.fillText("Taxi: " + taxilevel, canvas.width-offset_width,canvas.height-offsetHeight - heightdifference*2 - distance_font);

		ctx.font = "20px Arial";
		ctx.fillStyle = "black";
		ctx.fillText("Skillpoints: " + skillpoints, canvas.width-offset_width,canvas.height-offsetHeight - heightdifference*2 - distance_font - 22);

	}

	function act(){
		actTaxi();
		actTaxis();
		checkCargoHit();
		deliverCargo();
		collisionDetection();

		if(debug) {
			autoPilot();
		}
	}

	function actTaxi(){
		if (((pos_x + taxiWidth / 2) > fieldwidth) || ((pos_x - taxiWidth / 2) < 0) || ((pos_y + taxiHeight / 2) > fieldheight) || ((pos_y - taxiHeight / 2) < 0)) {

			//alert("Gameover. Points: " + points);
			//document.location.reload();
			lost();
		}


		if (leftPressed){
			direction = (((direction+(turningSpeed*dt))+Math.PI)%(2*Math.PI))-Math.PI;
		}
		if (rightPressed){
			if( (direction-(0.5*dt)) < (-Math.PI) ){
				direction = (direction-(turningSpeed*dt))+2*Math.PI;
			}
			else{
				direction = (((direction-(turningSpeed*dt))+Math.PI)%(2*Math.PI))-Math.PI;
			}
		}

		if (now - spawnTime > 1000) {


			if(breaking && breaking_power > 0){
				speed = speed - (Math.min(breaking_power, decelaration ))*dt;
				speed = Math.max(0,speed);
				breaking_power = breaking_power - (Math.min(breaking_power, decelaration))*dt;
			}

			if(speed < max_speed ){
				speed = speed + (acceleration*dt);
				if(speed > max_speed){
					speed = max_speed;
				}
			}

			if( breaking_power < breaking_power_max){
				breaking_power += (breaking_reload*dt);
				if(breaking_power > breaking_power_max){
					breaking_power = breaking_power_max;
				}
			}


			pos_x = pos_x + Math.sin(direction) * dt * speed;
			pos_y = pos_y + Math.cos(direction) * dt * speed;

		}
	}

	function actTaxis(){
		for (var t = 0; t < taxis.length; t++) {
			if(taxis[t].id != myID) {
				if (taxis[t].leftPressed){
					taxis[t].direction = (((taxis[t].direction+(turningSpeed*dt))+Math.PI)%(2*Math.PI))-Math.PI;
				}
				if (taxis[t].rightPressed){
					if( (taxis[t].direction-(0.5*dt)) < (-Math.PI) ){
						taxis[t].direction = (taxis[t].direction-(turningSpeed*dt))+2*Math.PI;
					}
					else{
						taxis[t].direction = (((taxis[t].direction-(turningSpeed*dt))+Math.PI)%(2*Math.PI))-Math.PI;
					}
				}

				taxis[t].pos_x = taxis[t].pos_x + Math.sin(taxis[t].direction)*dt*taxis[t].speed;
				taxis[t].pos_y = taxis[t].pos_y + Math.cos(taxis[t].direction)*dt*taxis[t].speed;
			}
		}
	}

	function reset(){

		var valid_pos = false;
		while(!valid_pos){

			pos_x = Math.floor((Math.random() * canvas.width-80) + 40);
			pos_y = Math.floor((Math.random() * canvas.height-80) + 40);

			for(h=0; h < houses.length; h++){

				var collision = doPolygonsIntersect(mycorners,houses[h]);
				if(!collision){
					valid_pos = true;
				}

			}

		}

		field_x = 0;
		field_y = 0;


		passengers = 0;

		direction = 0; // -PI to +Pi
		speed = 0;
		max_speed = 180;

		taxilevel = 0;
		max_passengers = getTaxiConfig(taxilevel).max_passengers;
		taxiWidth = getTaxiConfig(taxilevel).taxiWidth;
		taxiHeight = getTaxiConfig(taxilevel).taxiHeight;
		taxisize = 0

		handlingLevel = 0;
		turningSpeed = getHandling(handlingLevel);
		points = 0;
		spawnTime = Date.now();

		brakelevel = 0;
		decelaration = (getBrakeConfig(brakelevel)).decelaration;
		breaking_power_max = (getBrakeConfig(brakelevel)).breaking_power_max;
		breaking_reload = (getBrakeConfig(brakelevel)).breaking_reload;
		breaking_power = 200;
		breaking = false;


		level = 0;
		experience = 0;
		skillpoints = 0;

		taxiConfig = getTaxiConfig(taxisize);

	}

	function lost(){
		socket.emit("GameOver",{points:points, id:myID,name:name});
		reset();
	}

	function checkCargoHit(){
		for (var c = 0; c<cargo.length; c++){
			if (cargo[c].x < pos_x+taxiWidth/2 && cargo[c].x > pos_x - taxiWidth/2){
				if (cargo[c].y < pos_y+taxiHeight/2 && cargo[c].y > pos_y - taxiHeight/2){
					if(addCargo()){
						cargo.splice(c,1);
						socket.emit("cargo",c);
					}
				}
			}
		}
	}

	function addCargo(){
		if( passengers < max_passengers){
			passengers = passengers + 1;
			return true;
		}
		return false;
	}

	function deliverCargo(){

		if(pos_x < base.x + base.radius && pos_x > base.x - base.radius ){
			if(pos_y < base.y + base.radius && pos_y > base.y - base.radius ) {
				max_speed = max_speed + speed_gain * passengers;
				points = points + passengers;
				experience += passengers;
				while( experience >= getExperience(level)){
					experience -= getExperience(level);
					level++;
					skillpoints++;
				}
				if (passengers > 0) {
					//upgradeTaxi();
				}
				passengers = 0;
			}
		}

	}

	function getExperience(level){
		switch(level){
			case 0:
				return 1;
			case 1:
				return 2;
			case 2:
				return 3;
		}
		return 5;
	}

	function getBrakeConfig(brakelevel){
		switch(brakelevel){
			case 0:
				return { decelaration:50 , breaking_power_max: 200, breaking_reload: 10};
			case 1:
				return { decelaration:70 , breaking_power_max: 220, breaking_reload: 15};
			case 2:
				return { decelaration:90 , breaking_power_max: 240, breaking_reload: 18};
			case 3:
				return { decelaration:110 , breaking_power_max: 260, breaking_reload: 20};
			case 4:
				return { decelaration:130 , breaking_power_max: 280, breaking_reload: 22};
			case 5:
				return { decelaration:180 , breaking_power_max: 300, breaking_reload: 24};
		}
		return { decelaration:50 , breaking_power_max: 200, breaking_reload: 10};
	}

	function getHandling(handlingLevel){
		switch(handlingLevel){
			case 0:
				return 3;
			case 1:
				return 3.5;
			case 2:
				return 4;
			case 3:
				return 4.5;
			case 4:
				return 5;
			case 5:
				return 5.5;
		}
		return 3;
	}

	function getTaxiConfig(taxilevel){
		var configuration = {	passenger_offset_x:[],
			passenger_offset_y:[],
			pilot_x:0, pilot_y:0,
			max_passengers:1, taxiWidth:15,
			taxiHeight:30
		};
		switch(taxilevel){
			case 0:
				configuration.passenger_offset_x = [0];
				configuration.passenger_offset_y = [-4];
				configuration.pilot_x = 0;
				configuration.pilot_y = 4;
				break;
			case 1:
				configuration.passenger_offset_x = [-3,3];
				configuration.passenger_offset_y = [-4,-4];
				configuration.pilot_x = 0;
				configuration.pilot_y = 4;
				configuration.max_passengers = 2;
				configuration.taxiWidth = 20;
				configuration.taxiHeight = 30;
				break;
			case 2:
				configuration.passenger_offset_x = [-3,3,-3,3];
				configuration.passenger_offset_y = [0,0,-8,-8];
				configuration.pilot_x = 0;
				configuration.pilot_y = 8;
				configuration.max_passengers = 4;
				configuration.taxiWidth = 20;
				configuration.taxiHeight = 35;
				break;
			case 3:
				configuration.passenger_offset_x = [-3,3,-3,3,-3,3];
				configuration.passenger_offset_y = [3,3,-5,-5,-13,-13];
				configuration.pilot_x = 0;
				configuration.pilot_y = 13;
				configuration.max_passengers = 6;
				configuration.taxiWidth = 22;
				configuration.taxiHeight = 40;
				break;
			case 4:
				configuration.passenger_offset_x = [0,6,-6,0,6,-6,0,6,-6];
				configuration.passenger_offset_y = [3,3,3,-5,-5,-5,-13,-13,-13];
				configuration.pilot_x = 0;
				configuration.pilot_y = 13;
				configuration.max_passengers = 9;
				configuration.taxiWidth = 30;
				configuration.taxiHeight = 40;
				break;
			case 5:
				configuration.passenger_offset_x = [0,6,-6,0,6,-6,0,6,-6,0,6,-6];
				configuration.passenger_offset_y = [8,8,8,0,0,0,-8,-8,-8,-16,-16,-16];
				configuration.pilot_x = 0;
				configuration.pilot_y = 18;
				configuration.max_passengers = 12;
				configuration.taxiWidth = 30;
				configuration.taxiHeight = 50;
				break;
			case 6:
				configuration.passenger_offset_x = [0,6,-6,0,6,-6,0,6,-6,0,6,-6,0,6,-6];
				configuration.passenger_offset_y = [13,13,13,5,5,5,-3,-3,-3,-11,-11,-11,-19,-19,-19];
				configuration.pilot_x = 0;
				configuration.pilot_y = 23;
				configuration.max_passengers = 15;
				configuration.taxiWidth = 33;
				configuration.taxiHeight = 60;
				break;
			case 7:
			case 8:
			case 9:
			case 10:
			case 11:
		}
		return configuration;
	}

	function keyDownHandler(e) {
		if(e.keyCode == 39) {
			rightPressed = true;
		}
		else if(e.keyCode == 37) {
			leftPressed = true;
		}
		else if(e.keyCode == 68) {
			debug = !debug;
		}
		else if(e.keyCode == 70) {
			autoPilotturningSpeed++;
		}
		else if(e.keyCode == 49) {
			if(skillpoints > 0) {
				if (handlingLevel < handlingLevel_max) {
					handlingLevel++;
					turningSpeed = getHandling(handlingLevel);
					skillpoints--;
				}
			}
		}
		else if(e.keyCode == 50) {
			if(skillpoints > 0) {
				if (brakelevel < brakelevel_max) {
					brakelevel++;

					decelaration = (getBrakeConfig(brakelevel)).decelaration;
					breaking_power_max = (getBrakeConfig(brakelevel)).breaking_power_max;
					breaking_reload = (getBrakeConfig(brakelevel)).breaking_reload;

					skillpoints--;
				}
			}
		}
		else if(e.keyCode == 51) {
			if(skillpoints > 0) {
				if (taxilevel < taxilevel_max) {
					taxilevel++;

					taxiConfig = getTaxiConfig(taxilevel);
					max_passengers = getTaxiConfig(taxilevel).max_passengers;
					taxiWidth = getTaxiConfig(taxilevel).taxiWidth;
					taxiHeight = getTaxiConfig(taxilevel).taxiHeight;

					skillpoints--;
				}
			}
		}
		else if(e.keyCode == 40) {
			breaking = true;
		}
		console.log("key: " + e.keyCode);
	}

	function keyUpHandler(e) {
		if(e.keyCode == 39) {
			rightPressed = false;
		}
		else if(e.keyCode == 37) {
			leftPressed = false;
		}
		else if(e.keyCode == 40) {
			breaking = false;
		}
	}

	function logger(){

		if(now - lastLogged > logInterval ){
			lastLogged = now;
			//console.log("field: " +field_x+"/" + field_y);
			//console.log("window: " +window.innerWidth+"/" + window.innerHeight);
		}

	}

	function collisionDetection(){

		var c1 = rotatePoint([pos_x,pos_y], [pos_x+taxiWidth/2, pos_y+taxiHeight/2],direction);
		var c2 = rotatePoint([pos_x,pos_y], [pos_x+taxiWidth/2, pos_y-taxiHeight/2],direction);
		var c3 = rotatePoint([pos_x,pos_y], [pos_x-taxiWidth/2, pos_y+taxiHeight/2],direction);
		var c4 = rotatePoint([pos_x,pos_y], [pos_x-taxiWidth/2, pos_y-taxiHeight/2],direction);
		var mycorners = [
			{ 	x: c1[0],
				y: c1[1]
			},
			{ 	x: c2[0],
				y: c2[1]
			},
			{ 	x: c3[0],
				y: c3[1]
			},
			{ 	x: c4[0],
				y: c4[1]
			}
		];

		for(t=0; t < taxis.length; t++){

			if(taxis[t].id != myID){				

				var d1 = rotatePoint([taxis[t].pos_x,taxis[t].pos_y], [taxis[t].pos_x+taxis[t].taxiWidth/2, taxis[t].pos_y+taxis[t].taxiHeight/2],taxis[t].direction);
				var d2 = rotatePoint([taxis[t].pos_x,taxis[t].pos_y], [taxis[t].pos_x+taxis[t].taxiWidth/2, taxis[t].pos_y-taxis[t].taxiHeight/2],taxis[t].direction);
				var d3 = rotatePoint([taxis[t].pos_x,taxis[t].pos_y], [taxis[t].pos_x-taxis[t].taxiWidth/2, taxis[t].pos_y+taxis[t].taxiHeight/2],taxis[t].direction);
				var d4 = rotatePoint([taxis[t].pos_x,taxis[t].pos_y], [taxis[t].pos_x-taxis[t].taxiWidth/2, taxis[t].pos_y-taxis[t].taxiHeight/2],taxis[t].direction);
				var othercorners = [
					{ 	x: d1[0],
						y: d1[1]
					},
					{ 	x: d2[0],
						y: d2[1]
					},
					{ 	x: d3[0],
						y: d3[1]
					},
					{ 	x: d4[0],
						y: d4[1]
					}
				];

				var collision = doPolygonsIntersect(mycorners,othercorners);
				if(collision){
					lost();
				}

			}

		}

		for(h=0; h < houses.length; h++){

			var collision = doPolygonsIntersect(mycorners,houses[h]);
			if(collision){
				lost();
			}
		}

	}

	function rotatePoint(pivot, point, angle) {
		// Rotate clockwise, angle in radians
		var x = Math.round((Math.cos(angle) * (point[0] - pivot[0])) -
						(Math.sin(angle) * (point[1] - pivot[1])) +
						pivot[0]),
				y = Math.round((Math.sin(angle) * (point[0] - pivot[0])) +
						(Math.cos(angle) * (point[1] - pivot[1])) +
						pivot[1]);
		return [x, y];
	}

	/**
	 * Helper function to determine whether there is an intersection between the two polygons described
	 * by the lists of vertices. Uses the Separating Axis Theorem
	 *
	 * @param a an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon
	 * @param b an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon
	 * @return true if there is any intersection between the 2 polygons, false otherwise
	 */
	function doPolygonsIntersect (a, b) {
		var polygons = [a, b];
		var minA, maxA, projected, i, i1, j, minB, maxB;

		for (i = 0; i < polygons.length; i++) {

			// for each polygon, look at each edge of the polygon, and determine if it separates
			// the two shapes
			var polygon = polygons[i];
			for (i1 = 0; i1 < polygon.length; i1++) {

				// grab 2 vertices to create an edge
				var i2 = (i1 + 1) % polygon.length;
				var p1 = polygon[i1];
				var p2 = polygon[i2];

				// find the line perpendicular to this edge
				var normal = { x: p2.y - p1.y, y: p1.x - p2.x };

				minA = maxA = undefined;
				// for each vertex in the first shape, project it onto the line perpendicular to the edge
				// and keep track of the min and max of these values
				for (j = 0; j < a.length; j++) {
					projected = normal.x * a[j].x + normal.y * a[j].y;
					if ((minA == undefined) || projected < minA) {
						minA = projected;
					}
					if ((maxA == undefined) || projected > maxA) {
						maxA = projected;
					}
				}

				// for each vertex in the second shape, project it onto the line perpendicular to the edge
				// and keep track of the min and max of these values
				minB = maxB = undefined;
				for (j = 0; j < b.length; j++) {
					projected = normal.x * b[j].x + normal.y * b[j].y;
					if ((minB == undefined) || projected < minB) {
						minB = projected;
					}
					if ((maxB == undefined) || projected > maxB) {
						maxB = projected;
					}
				}

				// if there is no overlap between the projects, the edge we are looking at separates the two
				// polygons, and we know there is no overlap
				if (maxA < minB || maxB < minA) {
					//CONSOLE("polygons don't intersect!");
					return false;
				}
			}
		}
		return true;
	}

	</script>	
	
  </body>
</html>
